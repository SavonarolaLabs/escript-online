/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./main.js":
/*!*****************!*\
  !*** ./main.js ***!
  \*****************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _wallet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wallet.js */ \"./wallet.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\n\ndocument.addEventListener(\"DOMContentLoaded\", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n  var configDataElement, config, address, parties, partiesContainer, updateStatus;\n  return _regeneratorRuntime().wrap(function _callee$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        updateStatus = function _updateStatus() {\n          var addressInputs = document.querySelectorAll('.address-input');\n          var allFilled = Array.from(addressInputs).every(function (input) {\n            return input.value.trim() !== '';\n          });\n          var filledCount = Array.from(addressInputs).filter(function (input) {\n            return input.value.trim() !== '';\n          }).length;\n          var statusElement = document.getElementById('status');\n          var statusNotReadyElement = document.getElementById('statusNotReady');\n          document.getElementById('addresses-set').textContent = \"\".concat(filledCount, \"/\").concat(parties.length, \" Addresses set\");\n          if (allFilled) {\n            statusElement.style.display = 'inline-block';\n            statusNotReadyElement.style.display = 'none';\n          } else {\n            statusElement.style.display = 'none';\n            statusNotReadyElement.style.display = 'inline-block';\n          }\n        };\n        configDataElement = document.getElementById('configData');\n        config = JSON.parse(configDataElement.textContent);\n        address = config.address;\n        parties = config.parties;\n        document.getElementById('contract-address').textContent = address;\n        // @ts-ignore\n        document.getElementById(\"explorerLink\").href = \"https://explorer.ergoplatform.com/en/addresses/\" + address;\n        document.getElementById(\"connectWallet\").addEventListener(\"click\", _wallet_js__WEBPACK_IMPORTED_MODULE_0__.connectWallet);\n        document.getElementById(\"depositBtn\").addEventListener(\"click\", function () {\n          return (0,_wallet_js__WEBPACK_IMPORTED_MODULE_0__.deposit)(address, parties.map(function (p) {\n            return p.address;\n          }));\n        });\n        partiesContainer = document.getElementById('parties-container');\n        parties.forEach(function (party) {\n          var _party$name$charAt;\n          var partyDiv = document.createElement('div');\n          partyDiv.className = 'flex rounded-sm p-4 items-center gap-5 dark-bg';\n          partyDiv.innerHTML = \"\\n\\t\\t\\t<div class=\\\"rounded-full gray-bg items-center justify-center flex font-bold\\\"\\n\\t\\t\\t\\t style=\\\"height:3em;width:3em; border-right: 1px solid var(--color-cyan);\\\">\\n\\t\\t\\t\\t\".concat((_party$name$charAt = party.name.charAt(2)) !== null && _party$name$charAt !== void 0 ? _party$name$charAt : \"x\", \"\\n\\t\\t\\t</div>\\n\\t\\t\\t<div class=\\\"flex flex-col w-full\\\">\\n\\t\\t\\t\\t<div>\").concat(party.name, \"</div>\\n\\t\\t\\t\\t<input class=\\\"address-input w-full thin text-xl rounded\\\" value=\\\"\").concat(party.address, \"\\\" />\\n\\t\\t\\t</div>\\n\\t\\t\");\n          partiesContainer.appendChild(partyDiv);\n        });\n        document.querySelectorAll('.address-input').forEach(function (input) {\n          input.addEventListener('input', updateStatus);\n        });\n        updateStatus(); // Initial check\n      case 13:\n      case \"end\":\n        return _context.stop();\n    }\n  }, _callee);\n})));\n\n//# sourceURL=webpack://my-project/./main.js?");

/***/ }),

/***/ "./wallet.js":
/*!*******************!*\
  !*** ./wallet.js ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   connectWallet: () => (/* binding */ connectWallet),\n/* harmony export */   deposit: () => (/* binding */ deposit)\n/* harmony export */ });\n/* harmony import */ var _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fleet-sdk/common */ \"./node_modules/@fleet-sdk/common/dist/index.mjs\");\n/* harmony import */ var _fleet_sdk_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fleet-sdk/core */ \"./node_modules/@fleet-sdk/core/dist/index.mjs\");\n/* harmony import */ var _fleet_sdk_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fleet-sdk/core */ \"./node_modules/@fleet-sdk/core/node_modules/@fleet-sdk/serializer/dist/index.mjs\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\n\n\nfunction connectWallet() {\n  return _connectWallet.apply(this, arguments);\n}\n\n// @ts-ignore\nfunction _connectWallet() {\n  _connectWallet = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var wallet, connected, balanceInNanoErg;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          wallet = \"\";\n          connected = false;\n          balanceInNanoErg = 0; // @ts-ignore\n          if (!window.ergoConnector) {\n            console.log(\"Please install Nautilus Wallet\");\n          } else {\n            // @ts-ignore\n            console.log(\"Detected wallets:\", Object.keys(window.ergoConnector));\n            // @ts-ignore\n            wallet = Object.keys(window.ergoConnector)[0];\n          }\n          if (!wallet) {\n            _context.next = 8;\n            break;\n          }\n          _context.next = 7;\n          return ergoConnector[wallet].connect();\n        case 7:\n          connected = _context.sent;\n        case 8:\n          if (!connected) {\n            _context.next = 17;\n            break;\n          }\n          document.getElementById(\"connectWallet\").style.display = \"none\";\n          document.getElementById(\"disconnectWallet\").style.display = \"inline-block\";\n\n          // @ts-ignore\n          _context.next = 13;\n          return ergo.get_balance();\n        case 13:\n          balanceInNanoErg = _context.sent;\n          console.log(\"balance\", (balanceInNanoErg / Math.pow(10, 9)).toFixed(2));\n          _context.next = 18;\n          break;\n        case 17:\n          console.log(\"canceled\");\n        case 18:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _connectWallet.apply(this, arguments);\n}\nfunction deposit(_x, _x2) {\n  return _deposit.apply(this, arguments);\n}\nfunction _deposit() {\n  _deposit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(contract, pks) {\n    var nanoErg, tx, signedTx;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return connectWallet();\n        case 2:\n          // @ts-ignore\n          nanoErg = document.getElementById('nanoErgInput').value;\n          _context2.next = 5;\n          return createDepositTx(contract, pks, nanoErg);\n        case 5:\n          tx = _context2.sent;\n          _context2.next = 8;\n          return ergo.sign_tx(tx);\n        case 8:\n          signedTx = _context2.sent;\n          console.log(signedTx);\n        case 10:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _deposit.apply(this, arguments);\n}\nfunction createDepositTx(_x3, _x4, _x5) {\n  return _createDepositTx.apply(this, arguments);\n}\nfunction _createDepositTx() {\n  _createDepositTx = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(contract, pks, nanoErg) {\n    var blockchainHeight, inputBoxes, changeAddress, depositBox, unsignedTx;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.next = 2;\n          return fetchHeight();\n        case 2:\n          blockchainHeight = _context3.sent;\n          _context3.next = 5;\n          return ergo.get_utxos();\n        case 5:\n          inputBoxes = _context3.sent;\n          _context3.next = 8;\n          return ergo.get_change_address();\n        case 8:\n          changeAddress = _context3.sent;\n          depositBox = new _fleet_sdk_core__WEBPACK_IMPORTED_MODULE_0__.OutputBuilder(nanoErg, contract).setAdditionalRegisters({\n            R4: (0,_fleet_sdk_core__WEBPACK_IMPORTED_MODULE_1__.SColl)(_fleet_sdk_core__WEBPACK_IMPORTED_MODULE_1__.SByte, pks.map(function (pk) {\n              return [(0,_fleet_sdk_core__WEBPACK_IMPORTED_MODULE_1__.SGroupElement)(\n              // @ts-ignore\n              (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_2__.first)(_fleet_sdk_core__WEBPACK_IMPORTED_MODULE_0__.ErgoAddress.fromBase58(pk).getPublicKeys()))];\n            })).toHex()\n          });\n          unsignedTx = new _fleet_sdk_core__WEBPACK_IMPORTED_MODULE_0__.TransactionBuilder(blockchainHeight).from(inputBoxes).to(depositBox).sendChangeTo(changeAddress).payFee(_fleet_sdk_core__WEBPACK_IMPORTED_MODULE_0__.RECOMMENDED_MIN_FEE_VALUE).build().toEIP12Object();\n          return _context3.abrupt(\"return\", unsignedTx);\n        case 12:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return _createDepositTx.apply(this, arguments);\n}\nfunction fetchHeight() {\n  return _fetchHeight.apply(this, arguments);\n}\nfunction _fetchHeight() {\n  _fetchHeight = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n    var response, data;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          _context4.prev = 0;\n          _context4.next = 3;\n          return fetch(\"https://api.ergoplatform.com/api/v1/info\");\n        case 3:\n          response = _context4.sent;\n          _context4.next = 6;\n          return response.json();\n        case 6:\n          data = _context4.sent;\n          return _context4.abrupt(\"return\", data.height);\n        case 10:\n          _context4.prev = 10;\n          _context4.t0 = _context4[\"catch\"](0);\n          console.error(\"Error fetching data:\", _context4.t0);\n          return _context4.abrupt(\"return\", null);\n        case 14:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4, null, [[0, 10]]);\n  }));\n  return _fetchHeight.apply(this, arguments);\n}\n\n//# sourceURL=webpack://my-project/./wallet.js?");

/***/ }),

/***/ "./node_modules/@fleet-sdk/common/dist/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@fleet-sdk/common/dist/index.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressType: () => (/* binding */ AddressType),\n/* harmony export */   BlockchainProviderError: () => (/* binding */ BlockchainProviderError),\n/* harmony export */   Collection: () => (/* binding */ Collection),\n/* harmony export */   FleetError: () => (/* binding */ FleetError),\n/* harmony export */   Network: () => (/* binding */ Network),\n/* harmony export */   NotSupportedError: () => (/* binding */ NotSupportedError),\n/* harmony export */   _0n: () => (/* binding */ _0n),\n/* harmony export */   _10n: () => (/* binding */ _10n),\n/* harmony export */   _127n: () => (/* binding */ _127n),\n/* harmony export */   _128n: () => (/* binding */ _128n),\n/* harmony export */   _1n: () => (/* binding */ _1n),\n/* harmony export */   _63n: () => (/* binding */ _63n),\n/* harmony export */   _7n: () => (/* binding */ _7n),\n/* harmony export */   areEqual: () => (/* binding */ areEqual),\n/* harmony export */   areEqualBy: () => (/* binding */ areEqualBy),\n/* harmony export */   areRegistersDenselyPacked: () => (/* binding */ areRegistersDenselyPacked),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertInstanceOf: () => (/* binding */ assertInstanceOf),\n/* harmony export */   assertTypeOf: () => (/* binding */ assertTypeOf),\n/* harmony export */   at: () => (/* binding */ at),\n/* harmony export */   byteSizeOf: () => (/* binding */ byteSizeOf),\n/* harmony export */   chunk: () => (/* binding */ chunk),\n/* harmony export */   clearUndefined: () => (/* binding */ clearUndefined),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   decimalize: () => (/* binding */ decimalize),\n/* harmony export */   depthOf: () => (/* binding */ depthOf),\n/* harmony export */   endsWith: () => (/* binding */ endsWith),\n/* harmony export */   ensureBigInt: () => (/* binding */ ensureBigInt),\n/* harmony export */   ensureDefaults: () => (/* binding */ ensureDefaults),\n/* harmony export */   ensureUTxOBigInt: () => (/* binding */ ensureUTxOBigInt),\n/* harmony export */   ergoTreeHeaderFlags: () => (/* binding */ ergoTreeHeaderFlags),\n/* harmony export */   first: () => (/* binding */ first),\n/* harmony export */   hasDuplicates: () => (/* binding */ hasDuplicates),\n/* harmony export */   hasDuplicatesBy: () => (/* binding */ hasDuplicatesBy),\n/* harmony export */   hasKey: () => (/* binding */ hasKey),\n/* harmony export */   isDefined: () => (/* binding */ isDefined),\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty),\n/* harmony export */   isFalsy: () => (/* binding */ isFalsy),\n/* harmony export */   isHex: () => (/* binding */ isHex),\n/* harmony export */   isTruthy: () => (/* binding */ isTruthy),\n/* harmony export */   isUndefined: () => (/* binding */ isUndefined),\n/* harmony export */   last: () => (/* binding */ last),\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   orderBy: () => (/* binding */ orderBy),\n/* harmony export */   percent: () => (/* binding */ percent),\n/* harmony export */   some: () => (/* binding */ some),\n/* harmony export */   startsWith: () => (/* binding */ startsWith),\n/* harmony export */   sumBy: () => (/* binding */ sumBy),\n/* harmony export */   undecimalize: () => (/* binding */ undecimalize),\n/* harmony export */   uniq: () => (/* binding */ uniq),\n/* harmony export */   uniqBy: () => (/* binding */ uniqBy),\n/* harmony export */   utxoDiff: () => (/* binding */ utxoDiff),\n/* harmony export */   utxoFilter: () => (/* binding */ utxoFilter),\n/* harmony export */   utxoSum: () => (/* binding */ utxoSum)\n/* harmony export */ });\n// src/utils/assertions.ts\nfunction assert(condition, error) {\n  if (condition)\n    return;\n  let err = void 0;\n  switch (typeof error) {\n    case \"string\":\n      err = new Error(error);\n      break;\n    case \"function\":\n      err = new Error(error());\n      break;\n    default:\n      err = error;\n  }\n  throw err;\n}\nfunction assertTypeOf(obj, expected) {\n  const type = typeof obj;\n  if (type !== expected) {\n    throw new Error(`Expected an object of type '${expected}', got '${type}'.`);\n  }\n}\nvar toString = (value) => Object.prototype.toString.call(value);\nfunction getTypeName(value) {\n  if (value === null)\n    return \"null\";\n  const type = typeof value;\n  return type === \"object\" || type === \"function\" ? toString(value).slice(8, -1) : type;\n}\nfunction assertInstanceOf(obj, expected) {\n  const condition = obj instanceof expected;\n  if (!condition) {\n    throw new Error(`Expected an instance of '${expected.name}', got '${getTypeName(obj)}'.`);\n  }\n}\nfunction isEmpty(target) {\n  if (!target)\n    return true;\n  return Array.isArray(target) ? target.length === 0 : Object.keys(target).length === 0;\n}\nfunction some(target) {\n  return !isEmpty(target);\n}\nfunction isTruthy(value) {\n  return !!value;\n}\nfunction isFalsy(value) {\n  return !value;\n}\nfunction isUndefined(v) {\n  return v === void 0 || v === null || Number.isNaN(v);\n}\nfunction isDefined(v) {\n  return !isUndefined(v);\n}\nfunction hasKey(o, key) {\n  return Object.prototype.hasOwnProperty.call(o, key);\n}\n\n// src/utils/array.ts\nfunction first(array) {\n  if (!array)\n    return void 0;\n  assert(array.length > 0, \"Empty array.\");\n  return array[0];\n}\nfunction last(array) {\n  if (!array)\n    return void 0;\n  assert(array.length > 0, \"Empty array.\");\n  return at(array, -1);\n}\nfunction at(array, index) {\n  const len = array?.length;\n  if (!len)\n    return void 0;\n  if (index < 0) {\n    index += len;\n  }\n  return array[index];\n}\nfunction hasDuplicates(array) {\n  return array.some((item, index) => {\n    return array.indexOf(item) !== index;\n  });\n}\nfunction hasDuplicatesBy(array, selector) {\n  return array.some((item, index) => {\n    return array.findIndex((x) => selector(x) === selector(item)) !== index;\n  });\n}\nfunction chunk(array, size) {\n  if (array.length <= size) {\n    return [array];\n  }\n  const chunks = [];\n  for (let i = 0; i < array.length; i += size) {\n    chunks.push(array.slice(i, i + size));\n  }\n  return chunks;\n}\nfunction orderBy(array, iteratee, order = \"asc\") {\n  return [...array].sort((a, b) => {\n    if (iteratee(a) > iteratee(b)) {\n      return order === \"asc\" ? 1 : -1;\n    } else if (iteratee(a) < iteratee(b)) {\n      return order === \"asc\" ? -1 : 1;\n    } else {\n      return 0;\n    }\n  });\n}\nfunction areEqual(array1, array2) {\n  if (array1 === array2) {\n    return true;\n  }\n  if (array1.length != array2.length) {\n    return false;\n  }\n  for (let i = 0; i < array1.length; i++) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction areEqualBy(array1, array2, selector) {\n  if (array1 === array2) {\n    return true;\n  }\n  if (array1.length != array2.length) {\n    return false;\n  }\n  for (let i = 0; i < array1.length; i++) {\n    if (selector(array1[i]) !== selector(array2[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction startsWith(array, target) {\n  if (array === target) {\n    return true;\n  }\n  if (target.length > array.length) {\n    return false;\n  }\n  for (let i = 0; i < target.length; i++) {\n    if (target[i] !== array[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction endsWith(array, target) {\n  if (array === target) {\n    return true;\n  }\n  if (target.length > array.length) {\n    return false;\n  }\n  const offset = array.length - target.length;\n  for (let i = target.length - 1; i >= 0; i--) {\n    if (target[i] !== array[i + offset]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction uniq(array) {\n  if (isEmpty(array)) {\n    return array;\n  }\n  return Array.from(new Set(array));\n}\nfunction uniqBy(array, selector, selection = \"keep-first\") {\n  if (isEmpty(array)) {\n    return array;\n  }\n  return Array.from(\n    array.reduce((map, e) => {\n      const key = selector(e);\n      if (selection === \"keep-first\" && map.has(key)) {\n        return map;\n      }\n      return map.set(key, e);\n    }, /* @__PURE__ */ new Map()).values()\n  );\n}\nfunction depthOf(array) {\n  return Array.isArray(array) ? 1 + Math.max(0, ...array.map(depthOf)) : 0;\n}\n\n// src/utils/bigInt.ts\nvar _0n = BigInt(0);\nvar _1n = BigInt(1);\nvar _7n = BigInt(7);\nvar _10n = BigInt(10);\nvar _63n = BigInt(63);\nvar _127n = BigInt(127);\nvar _128n = BigInt(128);\nfunction ensureBigInt(number) {\n  return typeof number === \"bigint\" ? number : BigInt(number);\n}\nfunction undecimalize(decimalStr, options) {\n  if (!decimalStr) {\n    return _0n;\n  }\n  options = typeof options == \"number\" ? { decimals: options } : options;\n  if (isUndefined(options)) {\n    options = {};\n  }\n  options.decimals = options.decimals || 0;\n  options.decimalMark = options.decimalMark || \".\";\n  const fragments = decimalStr.split(options.decimalMark);\n  if (fragments.length > 2) {\n    throw new Error(\"Invalid numeric string.\");\n  }\n  let [integer, decimal] = fragments;\n  integer = _removeLeadingZeros(integer);\n  const negative = integer.startsWith(\"-\") ? \"-\" : \"\";\n  if (!decimal) {\n    decimal = \"0\".repeat(options.decimals);\n  } else if (decimal.length < options.decimals) {\n    decimal = decimal.padEnd(options.decimals, \"0\");\n  }\n  return BigInt(negative + _stripNonDigits(integer + decimal));\n}\nfunction _stripNonDigits(value) {\n  return value.replace(/\\D/g, \"\");\n}\nfunction decimalize(value, options) {\n  value = ensureBigInt(value);\n  if (!options) {\n    return value.toString();\n  }\n  options = typeof options == \"number\" ? { decimals: options } : options;\n  options.decimals = options.decimals || 0;\n  options.decimalMark = options.decimalMark || \".\";\n  const pow = _10n ** BigInt(options.decimals);\n  const integer = value / pow;\n  const decimal = value - integer * pow;\n  return _buildFormattedDecimal(integer.toString(10), decimal.toString(10), options);\n}\nfunction percent(value, percentage, precision = 2n) {\n  return value * percentage / 10n ** precision;\n}\nfunction _buildFormattedDecimal(integer, decimal, options) {\n  const integerPart = _addThousandMarks(integer, options.thousandMark);\n  const decimalPart = _stripTrailingZeros(decimal.padStart(options.decimals, \"0\"));\n  if (decimalPart) {\n    return `${integerPart}${options.decimalMark}${decimalPart}`;\n  } else {\n    return integerPart;\n  }\n}\nfunction _addThousandMarks(value, mark) {\n  if (!mark) {\n    return value;\n  }\n  return value.replace(/\\B(?=(\\d{3})+(?!\\d))/g, mark);\n}\nfunction _stripTrailingZeros(value) {\n  if (!value.endsWith(\"0\")) {\n    return value;\n  }\n  return value.replace(/\\.?0+$/, \"\");\n}\nfunction _removeLeadingZeros(value) {\n  if (!value.startsWith(\"0\")) {\n    return value;\n  }\n  return value.replace(/^0+\\.?/, \"\");\n}\nfunction sumBy(collection, iteratee, condition) {\n  let acc = _0n;\n  if (isEmpty(collection)) {\n    return acc;\n  }\n  for (const item of collection) {\n    if (isUndefined(condition) || condition(item)) {\n      acc += iteratee(item);\n    }\n  }\n  return acc;\n}\nfunction min(...numbers) {\n  let min2 = first(numbers);\n  for (const num of numbers) {\n    if (num < min2) {\n      min2 = num;\n    }\n  }\n  return min2;\n}\nfunction max(...numbers) {\n  let max2 = first(numbers);\n  for (const num of numbers) {\n    if (num > max2) {\n      max2 = num;\n    }\n  }\n  return max2;\n}\n\n// src/utils/utxo.ts\nvar NANOERGS_TOKEN_ID = \"nanoErgs\";\nfunction utxoSum(boxes, tokenId) {\n  const balances = {};\n  for (const box of boxes) {\n    if (isUndefined(tokenId) || tokenId === NANOERGS_TOKEN_ID) {\n      balances[NANOERGS_TOKEN_ID] = (balances[NANOERGS_TOKEN_ID] || _0n) + ensureBigInt(box.value);\n    }\n    if (tokenId !== NANOERGS_TOKEN_ID) {\n      for (const token of box.assets) {\n        if (isDefined(tokenId) && tokenId !== token.tokenId) {\n          continue;\n        }\n        balances[token.tokenId] = (balances[token.tokenId] || _0n) + ensureBigInt(token.amount);\n      }\n    }\n  }\n  if (isDefined(tokenId)) {\n    return balances[tokenId] || _0n;\n  }\n  return {\n    nanoErgs: balances[NANOERGS_TOKEN_ID] || _0n,\n    tokens: Object.keys(balances).filter((x) => x !== NANOERGS_TOKEN_ID).map((tokenId2) => ({ tokenId: tokenId2, amount: balances[tokenId2] }))\n  };\n}\nfunction utxoDiff(minuend, subtrahend) {\n  if (Array.isArray(minuend)) {\n    minuend = utxoSum(minuend);\n  }\n  if (Array.isArray(subtrahend)) {\n    subtrahend = utxoSum(subtrahend);\n  }\n  const tokens = [];\n  const nanoErgs = minuend.nanoErgs - subtrahend.nanoErgs;\n  for (const token of minuend.tokens) {\n    const balance = token.amount - (subtrahend.tokens.find((t) => t.tokenId === token.tokenId)?.amount || _0n);\n    if (balance !== _0n) {\n      tokens.push({ tokenId: token.tokenId, amount: balance });\n    }\n  }\n  return { nanoErgs, tokens };\n}\nvar MIN_NON_MANDATORY_REGISTER_INDEX = 4;\nvar MAX_NON_MANDATORY_REGISTER_INDEX = 9;\nfunction areRegistersDenselyPacked(registers) {\n  let lastIndex = 0;\n  for (let i = MIN_NON_MANDATORY_REGISTER_INDEX; i <= MAX_NON_MANDATORY_REGISTER_INDEX; i++) {\n    const key = `R${i}`;\n    if (registers[key]) {\n      if (i === MIN_NON_MANDATORY_REGISTER_INDEX) {\n        lastIndex = i;\n        continue;\n      }\n      if (i - lastIndex > 1) {\n        return false;\n      }\n      lastIndex = i;\n    }\n  }\n  return true;\n}\nfunction utxoFilter(utxos, filterParams) {\n  if (isEmpty(filterParams) || isEmpty(utxos)) {\n    return utxos;\n  }\n  const { by, max: max2 } = filterParams;\n  let filtered = utxos;\n  if (by) {\n    filtered = utxos.filter(by);\n    if (isEmpty(filtered)) {\n      return filtered;\n    }\n  }\n  if (!max2) {\n    return filtered;\n  }\n  if (isDefined(max2.aggregatedDistinctTokens)) {\n    const tokenIds = _getDistinctTokenIds(filtered, max2.aggregatedDistinctTokens);\n    filtered = filtered.filter(\n      (utxo) => isEmpty(utxo.assets) || utxo.assets.every((token) => tokenIds.has(token.tokenId))\n    );\n  }\n  if (isDefined(max2.count) && filtered.length > max2.count) {\n    filtered = filtered.slice(0, max2.count);\n  }\n  return filtered;\n}\nfunction _getDistinctTokenIds(utxos, max2) {\n  const tokenIds = /* @__PURE__ */ new Set();\n  for (let i = 0; i < utxos.length && tokenIds.size < max2; i++) {\n    if (isEmpty(utxos[i].assets) || utxos[i].assets.length > max2) {\n      continue;\n    }\n    for (const token of utxos[i].assets) {\n      tokenIds.add(token.tokenId);\n    }\n  }\n  return tokenIds;\n}\nfunction ensureUTxOBigInt(box) {\n  return {\n    ...box,\n    value: ensureBigInt(box.value),\n    assets: box.assets.map((token) => ({\n      tokenId: token.tokenId,\n      amount: ensureBigInt(token.amount)\n    }))\n  };\n}\n\n// src/utils/object.ts\nfunction clearUndefined(value) {\n  const result = {};\n  for (const key in value) {\n    const val = value[key];\n    if (!isUndefined(val)) {\n      result[key] = val;\n    }\n  }\n  return result;\n}\nfunction ensureDefaults(partial, defaults, options) {\n  if (isEmpty(partial))\n    return defaults;\n  if (options?.keepUndefinedKeys)\n    return { ...defaults, ...partial };\n  const merged = { ...defaults, ...partial };\n  for (const key in merged) {\n    merged[key] = partial[key] ?? defaults[key];\n  }\n  return merged;\n}\n\n// src/utils/bytes.ts\nfunction concatBytes(...arrays) {\n  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n  let pad = 0;\n  for (const bytes of arrays) {\n    assertInstanceOf(bytes, Uint8Array);\n    r.set(bytes, pad);\n    pad += bytes.length;\n  }\n  return r;\n}\nfunction isHex(value) {\n  if (!value || value.length % 2)\n    return false;\n  if (!value.startsWith(\"0x\")) {\n    value = \"0x\" + value;\n  }\n  return !isNaN(Number(value));\n}\nfunction byteSizeOf(hex) {\n  return hex.length / 2;\n}\n\n// src/types/common.ts\nvar Network = /* @__PURE__ */ ((Network2) => {\n  Network2[Network2[\"Mainnet\"] = 0] = \"Mainnet\";\n  Network2[Network2[\"Testnet\"] = 16] = \"Testnet\";\n  return Network2;\n})(Network || {});\nvar AddressType = /* @__PURE__ */ ((AddressType2) => {\n  AddressType2[AddressType2[\"P2PK\"] = 1] = \"P2PK\";\n  AddressType2[AddressType2[\"P2SH\"] = 2] = \"P2SH\";\n  AddressType2[AddressType2[\"P2S\"] = 3] = \"P2S\";\n  return AddressType2;\n})(AddressType || {});\nvar ergoTreeHeaderFlags = {\n  sizeInclusion: 8,\n  constantSegregation: 16\n};\n\n// src/models/collection.ts\nvar Collection = class {\n  _items;\n  constructor() {\n    this._items = [];\n  }\n  _isIndexOutOfBounds(index) {\n    return index < 0 || index >= this._items.length;\n  }\n  [Symbol.iterator]() {\n    let counter = 0;\n    return {\n      next: () => {\n        return {\n          done: counter >= this.length,\n          value: this._items[counter++]\n        };\n      }\n    };\n  }\n  /**\n   * Number of items in the collection\n   */\n  get length() {\n    return this._items.length;\n  }\n  /**\n   * True if the collection is empty\n   */\n  get isEmpty() {\n    return this.length === 0;\n  }\n  /**\n   * Get item at index\n   * @param index\n   * @throws RangeError if index is out of bounds\n   */\n  at(index) {\n    if (this._isIndexOutOfBounds(index)) {\n      throw new RangeError(`Index '${index}' is out of range.`);\n    }\n    return this._items[index];\n  }\n  /**\n   * Add item to the collection\n   * @param items\n   * @param options\n   * @returns The new length of the collection\n   */\n  add(items, options) {\n    return this._addOneOrMore(items, options);\n  }\n  _addOne(item, options) {\n    if (isDefined(options) && isDefined(options.index)) {\n      if (options.index === this.length) {\n        this._items.push(this._map(item));\n        return this.length;\n      }\n      if (this._isIndexOutOfBounds(options.index)) {\n        throw new RangeError(`Index '${options.index}' is out of range.`);\n      }\n      this._items.splice(options.index, 0, this._map(item));\n      return this.length;\n    }\n    this._items.push(this._map(item));\n    return this._items.length;\n  }\n  _addOneOrMore(items, options) {\n    if (Array.isArray(items)) {\n      if (isDefined(options) && isDefined(options.index)) {\n        items = items.reverse();\n      }\n      for (const item of items) {\n        this._addOne(item, options);\n      }\n    } else {\n      this._addOne(items, options);\n    }\n    return this.length;\n  }\n  /**\n   * Get the collection as an array\n   */\n  toArray() {\n    return [...this._items];\n  }\n  reduce(callbackFn, initialValue) {\n    return this._items.reduce(callbackFn, initialValue);\n  }\n};\n\n// src/error.ts\nvar FleetError = class extends Error {\n  constructor(message, options) {\n    super(message, options);\n    Object.setPrototypeOf(this, new.target.prototype);\n    this.name = new.target.name;\n  }\n};\nvar NotSupportedError = class extends FleetError {\n  constructor(message) {\n    super(message);\n  }\n};\nvar BlockchainProviderError = class extends FleetError {\n  constructor(message, options) {\n    super(message, options);\n  }\n};\n\n\n//# sourceMappingURL=out.js.map\n//# sourceMappingURL=index.mjs.map\n\n//# sourceURL=webpack://my-project/./node_modules/@fleet-sdk/common/dist/index.mjs?");

/***/ }),

/***/ "./node_modules/@fleet-sdk/core/dist/index.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@fleet-sdk/core/dist/index.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AccumulativeSelectionStrategy: () => (/* binding */ AccumulativeSelectionStrategy),\n/* harmony export */   AddressType: () => (/* reexport safe */ _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.AddressType),\n/* harmony export */   BOX_VALUE_PER_BYTE: () => (/* binding */ BOX_VALUE_PER_BYTE),\n/* harmony export */   BoxSelector: () => (/* binding */ BoxSelector),\n/* harmony export */   CherryPickSelectionStrategy: () => (/* binding */ CherryPickSelectionStrategy),\n/* harmony export */   CustomSelectionStrategy: () => (/* binding */ CustomSelectionStrategy),\n/* harmony export */   DuplicateInputError: () => (/* binding */ DuplicateInputError),\n/* harmony export */   DuplicateInputSelectionError: () => (/* binding */ DuplicateInputSelectionError),\n/* harmony export */   ErgoAddress: () => (/* binding */ ErgoAddress),\n/* harmony export */   ErgoBox: () => (/* binding */ ErgoBox),\n/* harmony export */   ErgoTree: () => (/* binding */ ErgoTree),\n/* harmony export */   ErgoUnsignedInput: () => (/* binding */ ErgoUnsignedInput),\n/* harmony export */   ErgoUnsignedTransaction: () => (/* binding */ ErgoUnsignedTransaction),\n/* harmony export */   FEE_CONTRACT: () => (/* binding */ FEE_CONTRACT),\n/* harmony export */   InputsCollection: () => (/* binding */ InputsCollection),\n/* harmony export */   InsufficientInputs: () => (/* binding */ InsufficientInputs),\n/* harmony export */   InsufficientTokenAmount: () => (/* binding */ InsufficientTokenAmount),\n/* harmony export */   InvalidAddress: () => (/* binding */ InvalidAddress),\n/* harmony export */   InvalidInput: () => (/* binding */ InvalidInput),\n/* harmony export */   InvalidRegistersPacking: () => (/* binding */ InvalidRegistersPacking),\n/* harmony export */   MAX_TOKENS_PER_BOX: () => (/* binding */ MAX_TOKENS_PER_BOX),\n/* harmony export */   MalformedTransaction: () => (/* binding */ MalformedTransaction),\n/* harmony export */   MaxTokensOverflow: () => (/* binding */ MaxTokensOverflow),\n/* harmony export */   Network: () => (/* reexport safe */ _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.Network),\n/* harmony export */   NotAllowedTokenBurning: () => (/* binding */ NotAllowedTokenBurning),\n/* harmony export */   NotFoundError: () => (/* binding */ NotFoundError),\n/* harmony export */   OutputBuilder: () => (/* binding */ OutputBuilder),\n/* harmony export */   OutputsCollection: () => (/* binding */ OutputsCollection),\n/* harmony export */   RECOMMENDED_MIN_FEE_VALUE: () => (/* binding */ RECOMMENDED_MIN_FEE_VALUE),\n/* harmony export */   SAFE_MIN_BOX_VALUE: () => (/* binding */ SAFE_MIN_BOX_VALUE),\n/* harmony export */   SBigInt: () => (/* reexport safe */ _fleet_sdk_serializer__WEBPACK_IMPORTED_MODULE_1__.SBigInt),\n/* harmony export */   SBool: () => (/* reexport safe */ _fleet_sdk_serializer__WEBPACK_IMPORTED_MODULE_1__.SBool),\n/* harmony export */   SByte: () => (/* reexport safe */ _fleet_sdk_serializer__WEBPACK_IMPORTED_MODULE_1__.SByte),\n/* harmony export */   SColl: () => (/* reexport safe */ _fleet_sdk_serializer__WEBPACK_IMPORTED_MODULE_1__.SColl),\n/* harmony export */   SCollType: () => (/* reexport safe */ _fleet_sdk_serializer__WEBPACK_IMPORTED_MODULE_1__.SCollType),\n/* harmony export */   SConstant: () => (/* binding */ SConstant2),\n/* harmony export */   SGroupElement: () => (/* reexport safe */ _fleet_sdk_serializer__WEBPACK_IMPORTED_MODULE_1__.SGroupElement),\n/* harmony export */   SInt: () => (/* reexport safe */ _fleet_sdk_serializer__WEBPACK_IMPORTED_MODULE_1__.SInt),\n/* harmony export */   SLong: () => (/* reexport safe */ _fleet_sdk_serializer__WEBPACK_IMPORTED_MODULE_1__.SLong),\n/* harmony export */   SParse: () => (/* binding */ SParse),\n/* harmony export */   SShort: () => (/* reexport safe */ _fleet_sdk_serializer__WEBPACK_IMPORTED_MODULE_1__.SShort),\n/* harmony export */   SSigmaProp: () => (/* reexport safe */ _fleet_sdk_serializer__WEBPACK_IMPORTED_MODULE_1__.SSigmaProp),\n/* harmony export */   SType: () => (/* reexport safe */ _fleet_sdk_serializer__WEBPACK_IMPORTED_MODULE_1__.SType),\n/* harmony export */   SUnit: () => (/* reexport safe */ _fleet_sdk_serializer__WEBPACK_IMPORTED_MODULE_1__.SUnit),\n/* harmony export */   TokensCollection: () => (/* binding */ TokensCollection),\n/* harmony export */   TransactionBuilder: () => (/* binding */ TransactionBuilder2),\n/* harmony export */   UndefinedCreationHeight: () => (/* binding */ UndefinedCreationHeight),\n/* harmony export */   UndefinedMintingContext: () => (/* binding */ UndefinedMintingContext),\n/* harmony export */   estimateMinBoxValue: () => (/* binding */ estimateMinBoxValue)\n/* harmony export */ });\n/* harmony import */ var _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fleet-sdk/common */ \"./node_modules/@fleet-sdk/core/node_modules/@fleet-sdk/common/dist/index.mjs\");\n/* harmony import */ var _fleet_sdk_crypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fleet-sdk/crypto */ \"./node_modules/@fleet-sdk/core/node_modules/@fleet-sdk/crypto/dist/index.mjs\");\n/* harmony import */ var _fleet_sdk_serializer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fleet-sdk/serializer */ \"./node_modules/@fleet-sdk/core/node_modules/@fleet-sdk/serializer/dist/index.mjs\");\n\n\n\n\n\n\n// src/builder/selector/boxSelector.ts\n\n// src/errors/duplicateInputSelectionError.ts\nvar DuplicateInputSelectionError = class extends Error {\n  constructor() {\n    super(`One or more inputs was selected more than one time by the current selection strategy.`);\n  }\n};\nvar InsufficientInputs = class extends Error {\n  unreached;\n  constructor(unreached) {\n    const strings = [];\n    if (unreached.nanoErgs) {\n      strings.push(buildString(\"nanoErgs\", unreached.nanoErgs));\n    }\n    if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.some)(unreached.tokens)) {\n      for (const token of unreached.tokens) {\n        strings.push(buildString(token.tokenId, token.amount));\n      }\n    }\n    super(`Insufficient inputs:${strings.join()}`);\n    this.unreached = unreached;\n  }\n};\nfunction buildString(tokenId, amount) {\n  return `\n  > ${tokenId}: ${amount?.toString()}`;\n}\nvar AccumulativeSelectionStrategy = class {\n  _inputs;\n  select(inputs, target) {\n    this._inputs = inputs;\n    let selection = [];\n    if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.some)(target.tokens)) {\n      selection = this._selectTokens(target.tokens);\n    }\n    const selectedNanoErgs = (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.sumBy)(selection, (input) => input.value);\n    if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(target.nanoErgs) && (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(target.tokens) || (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isDefined)(target.nanoErgs) && selectedNanoErgs < target.nanoErgs) {\n      const targetAmount = (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isDefined)(target.nanoErgs) ? target.nanoErgs - selectedNanoErgs : void 0;\n      selection = selection.concat(this._select(targetAmount));\n    }\n    return selection;\n  }\n  _selectTokens(targets) {\n    let selection = [];\n    for (const target of targets) {\n      const targetAmount = (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isDefined)(target.amount) ? target.amount - (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.utxoSum)(selection, target.tokenId) : void 0;\n      if (targetAmount && targetAmount <= _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._0n) {\n        continue;\n      }\n      selection = selection.concat(this._select(targetAmount, target.tokenId));\n    }\n    return selection;\n  }\n  _select(target, tokenId) {\n    const inputs = this._inputs;\n    let acc = _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._0n;\n    let selection = [];\n    if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(target)) {\n      if (tokenId) {\n        selection = inputs.filter((x) => x.assets.some((asset) => asset.tokenId === tokenId));\n      } else {\n        selection = inputs;\n      }\n    } else {\n      for (let i = 0; i < inputs.length && acc < target; i++) {\n        if (tokenId) {\n          for (const token of inputs[i].assets) {\n            if (token.tokenId !== tokenId) {\n              continue;\n            }\n            acc += token.amount;\n            selection.push(inputs[i]);\n          }\n        } else {\n          acc += inputs[i].value;\n          selection.push(inputs[i]);\n        }\n      }\n    }\n    if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.some)(selection)) {\n      this._inputs = this._inputs.filter((input) => !selection.includes(input));\n    }\n    return selection;\n  }\n};\n\n// src/builder/selector/strategies/customSelectionStrategy.ts\nvar CustomSelectionStrategy = class {\n  _selector;\n  constructor(selector) {\n    this._selector = selector;\n  }\n  select(inputs, target) {\n    return this._selector(inputs, target);\n  }\n};\n\n// src/builder/selector/boxSelector.ts\nvar BoxSelector = class {\n  _inputs;\n  _strategy;\n  _ensureFilterPredicate;\n  _selector;\n  _sortDirection;\n  _ensureInclusionBoxIds;\n  constructor(inputs) {\n    this._inputs = inputs;\n  }\n  defineStrategy(strategy) {\n    if (this._isISelectionStrategyImplementation(strategy)) {\n      this._strategy = strategy;\n    } else {\n      this._strategy = new CustomSelectionStrategy(strategy);\n    }\n    return this;\n  }\n  select(target) {\n    if (!this._strategy) {\n      this._strategy = new AccumulativeSelectionStrategy();\n    }\n    const remaining = this._deepCloneTarget(target);\n    let unselected = [...this._inputs];\n    let selected = [];\n    const predicate = this._ensureFilterPredicate;\n    const inclusion = this._ensureInclusionBoxIds;\n    if (predicate) {\n      if (inclusion) {\n        selected = unselected.filter((box) => predicate(box) || inclusion.has(box.boxId));\n      } else {\n        selected = unselected.filter(predicate);\n      }\n    } else if (inclusion) {\n      selected = unselected.filter((box) => inclusion.has(box.boxId));\n    }\n    if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.some)(selected)) {\n      unselected = unselected.filter((box) => !selected.some((sel) => sel.boxId === box.boxId));\n      if (remaining.nanoErgs && remaining.nanoErgs > _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._0n) {\n        remaining.nanoErgs -= (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.sumBy)(selected, (input) => input.value);\n      }\n      if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.some)(remaining.tokens) && selected.some((input) => !(0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(input.assets))) {\n        for (const t of remaining.tokens) {\n          if (t.amount && t.amount > _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._0n) {\n            t.amount -= (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.utxoSum)(selected, t.tokenId);\n          }\n        }\n      }\n    }\n    if (this._selector) {\n      unselected = (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.orderBy)(unselected, this._selector, this._sortDirection || \"asc\");\n    }\n    selected = selected.concat(this._strategy.select(unselected, remaining));\n    if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.hasDuplicatesBy)(selected, (item) => item.boxId)) {\n      throw new DuplicateInputSelectionError();\n    }\n    const unreached = this._getUnreachedTargets(selected, target);\n    if (unreached.nanoErgs || (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.some)(unreached.tokens)) {\n      throw new InsufficientInputs(unreached);\n    }\n    return selected;\n  }\n  _deepCloneTarget(target) {\n    return {\n      nanoErgs: target.nanoErgs,\n      tokens: target.tokens ? target.tokens.map((t) => ({ tokenId: t.tokenId, amount: t.amount })) : void 0\n    };\n  }\n  _getUnreachedTargets(inputs, target) {\n    const unreached = { nanoErgs: void 0, tokens: void 0 };\n    const selectedNanoergs = (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.sumBy)(inputs, (input) => input.value);\n    if (target.nanoErgs && target.nanoErgs > selectedNanoergs) {\n      unreached.nanoErgs = target.nanoErgs - selectedNanoergs;\n    }\n    if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(target.tokens)) {\n      return unreached;\n    }\n    for (const tokenTarget of target.tokens) {\n      const totalSelected = (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.utxoSum)(inputs, tokenTarget.tokenId);\n      if (tokenTarget.amount && tokenTarget.amount > totalSelected) {\n        if (tokenTarget.tokenId === (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.first)(inputs).boxId) {\n          continue;\n        }\n        if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(unreached.tokens)) {\n          unreached.tokens = [];\n        }\n        unreached.tokens.push({\n          tokenId: tokenTarget.tokenId,\n          amount: tokenTarget.amount - totalSelected\n        });\n      }\n    }\n    return unreached;\n  }\n  ensureInclusion(predicateOrBoxIds) {\n    if (typeof predicateOrBoxIds === \"function\") {\n      this._ensureFilterPredicate = predicateOrBoxIds;\n    } else if (predicateOrBoxIds === \"all\") {\n      this._ensureFilterPredicate = (box) => box.value > 0n;\n    } else {\n      if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(this._ensureInclusionBoxIds)) {\n        this._ensureInclusionBoxIds = /* @__PURE__ */ new Set();\n      }\n      if (Array.isArray(predicateOrBoxIds)) {\n        for (const boxId of predicateOrBoxIds) {\n          this._ensureInclusionBoxIds.add(boxId);\n        }\n      } else {\n        this._ensureInclusionBoxIds.add(predicateOrBoxIds);\n      }\n    }\n    return this;\n  }\n  orderBy(selector, direction) {\n    this._selector = selector;\n    this._sortDirection = direction;\n    return this;\n  }\n  _isISelectionStrategyImplementation(obj) {\n    if (obj.select) {\n      return true;\n    }\n    return false;\n  }\n  static buildTargetFrom(boxes) {\n    const tokens = {};\n    let nanoErgs = _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._0n;\n    for (const box of boxes) {\n      nanoErgs += (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.ensureBigInt)(box.value);\n      for (const token of box.assets) {\n        tokens[token.tokenId] = (tokens[token.tokenId] || _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._0n) + (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.ensureBigInt)(token.amount);\n      }\n    }\n    return {\n      nanoErgs,\n      tokens: Object.keys(tokens).map((tokenId) => ({ tokenId, amount: tokens[tokenId] }))\n    };\n  }\n};\nvar CherryPickSelectionStrategy = class extends AccumulativeSelectionStrategy {\n  select(inputs, target) {\n    const orderedInputs = (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.orderBy)(\n      inputs,\n      (x) => new Set(x.assets.map((asset) => asset.tokenId)).size,\n      \"asc\"\n    );\n    return super.select(orderedInputs, target);\n  }\n};\n\n// src/errors/duplicateInputError.ts\nvar DuplicateInputError = class extends Error {\n  constructor(boxId) {\n    super(`Box '${boxId}' is already included.`);\n  }\n};\n\n// src/errors/insufficientTokenAmount.ts\nvar InsufficientTokenAmount = class extends Error {\n  constructor(message) {\n    super(message);\n  }\n};\n\n// src/errors/invalidAddress.ts\nvar InvalidAddress = class extends Error {\n  constructor(address) {\n    super(`Invalid Ergo address: ${address}`);\n  }\n};\n\n// src/errors/invalidInput.ts\nvar InvalidInput = class extends Error {\n  constructor(boxId) {\n    super(`Invalid input: ${boxId}`);\n  }\n};\n\n// src/errors/invalidRegistersPacking.ts\nvar InvalidRegistersPacking = class extends Error {\n  constructor() {\n    super(\n      `Registers should be densely packed. This means that it's not possible to use a register like 'R7' without filling 'R6', 'R5' and 'R4', for example.`\n    );\n  }\n};\n\n// src/errors/malformedTransaction.ts\nvar MalformedTransaction = class extends Error {\n  constructor(message) {\n    super(`Malformed transaction: ${message}`);\n  }\n};\nvar MAX_TOKENS_PER_BOX = 120;\nvar TokensCollection = class extends _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.Collection {\n  #minting;\n  constructor(tokens, options) {\n    super();\n    if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isDefined)(tokens)) {\n      this.add(tokens, options);\n    }\n  }\n  get minting() {\n    if (!this.#minting)\n      return;\n    return { ...this.#minting.metadata, amount: this._items[this.#minting.index].amount };\n  }\n  _map(token) {\n    return { tokenId: token.tokenId, amount: (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.ensureBigInt)(token.amount) };\n  }\n  _addOne(token, options) {\n    if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(options) || options.sum && (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(options.index)) {\n      if (this._sum(this._map(token)))\n        return this.length;\n    }\n    if (this._items.length >= MAX_TOKENS_PER_BOX)\n      throw new MaxTokensOverflow();\n    super._addOne(token, options);\n    return this.length;\n  }\n  add(items, options) {\n    if (Array.isArray(items)) {\n      if (items.some((x) => !x.tokenId))\n        throw new _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.FleetError(\"TokenID is required.\");\n    } else if (!items.tokenId) {\n      throw new _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.FleetError(\"TokenID is required.\");\n    }\n    return super.add(items, options);\n  }\n  mint(token) {\n    if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isDefined)(this.#minting)) {\n      throw new _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.FleetError(\"Only one minting token is allowed per transaction.\");\n    } else {\n      const len = super.add({ tokenId: token.tokenId, amount: token.amount });\n      this.#minting = { index: len - 1, metadata: token };\n    }\n    return this.length;\n  }\n  _sum(token) {\n    for (const t of this._items) {\n      if (t.tokenId === token.tokenId) {\n        t.amount += token.amount;\n        return true;\n      }\n    }\n    return false;\n  }\n  remove(tokenIdOrIndex, amount) {\n    let index = -1;\n    if (typeof tokenIdOrIndex === \"number\") {\n      if (this._isIndexOutOfBounds(tokenIdOrIndex)) {\n        throw new RangeError(`Index '${tokenIdOrIndex}' is out of range.`);\n      }\n      index = tokenIdOrIndex;\n    } else {\n      index = this._items.findIndex((token) => token.tokenId === tokenIdOrIndex);\n      if (this._isIndexOutOfBounds(index)) {\n        throw new NotFoundError(`TokenId '${tokenIdOrIndex}' not found in assets collection.`);\n      }\n    }\n    if (amount && index > -1) {\n      const bigAmount = (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.ensureBigInt)(amount);\n      const token = this._items[index];\n      if (bigAmount > token.amount) {\n        throw new InsufficientTokenAmount(\n          `Insufficient token amount to perform a subtraction operation.`\n        );\n      } else if (bigAmount < token.amount) {\n        token.amount -= bigAmount;\n        return this.length;\n      }\n    }\n    this._items.splice(index, 1);\n    return this.length;\n  }\n  contains(tokenId) {\n    return this._items.some((x) => x.tokenId === tokenId);\n  }\n  toArray(mintingTokenId) {\n    if (this.minting) {\n      if (!mintingTokenId)\n        throw new UndefinedMintingContext();\n      return this._items.map((x) => ({\n        tokenId: x.tokenId ? x.tokenId : mintingTokenId,\n        amount: x.amount\n      }));\n    } else {\n      return super.toArray();\n    }\n  }\n};\n\n// src/errors/maxTokensOverflow.ts\nvar MaxTokensOverflow = class extends Error {\n  constructor() {\n    super(`A box must contain no more than ${MAX_TOKENS_PER_BOX} distinct tokens.`);\n  }\n};\n\n// src/errors/notAllowedTokenBurning.ts\nvar NotAllowedTokenBurning = class extends Error {\n  constructor() {\n    super(\n      \"This transaction is trying to burn tokens. If that's your intention you must explicitly allow token burning on TransactionBuilder.configure() method. If no, a change address should be provided.\"\n    );\n  }\n};\n\n// src/errors/notFoundError.ts\nvar NotFoundError = class extends Error {\n  constructor(message) {\n    super(message);\n  }\n};\n\n// src/errors/undefinedCreationHeight.ts\nvar UndefinedCreationHeight = class extends Error {\n  constructor() {\n    super(\n      \"Minting context is undefined. Transaction's inputs must be included in order to determine minting token id.\"\n    );\n  }\n};\n\n// src/errors/undefinedMintingContext.ts\nvar UndefinedMintingContext = class extends Error {\n  constructor() {\n    super(\"Creation Height is undefined.\");\n  }\n};\nvar CHECKSUM_LENGTH = 4;\nvar BLAKE_256_HASH_LENGTH = 32;\nvar P2PK_ERGOTREE_PREFIX = _fleet_sdk_crypto__WEBPACK_IMPORTED_MODULE_2__.hex.decode(\"0008cd\");\nvar P2PK_ERGOTREE_LENGTH = 36;\nvar P2SH_ERGOTREE_SUFFIX = _fleet_sdk_crypto__WEBPACK_IMPORTED_MODULE_2__.hex.decode(\"d40801\");\nvar P2SH_ERGOTREE_PREFIX = _fleet_sdk_crypto__WEBPACK_IMPORTED_MODULE_2__.hex.decode(\"00ea02d193b4cbe4e3010e040004300e18\");\nvar P2SH_ERGOTREE_LENGTH = 44;\nvar P2SH_HASH_LENGTH = 24;\nfunction _getEncodedNetworkType(addressBytes) {\n  return (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.first)(addressBytes) & 240;\n}\nfunction _getEncodedAddressType(addressBytes) {\n  return (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.first)(addressBytes) & 15;\n}\nfunction _ensureBytes(content) {\n  if (typeof content === \"string\") {\n    return _fleet_sdk_crypto__WEBPACK_IMPORTED_MODULE_2__.hex.decode(content);\n  }\n  return content;\n}\nfunction _getErgoTreeType(ergoTree) {\n  if (ergoTree.length === P2PK_ERGOTREE_LENGTH && (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.startsWith)(ergoTree, P2PK_ERGOTREE_PREFIX)) {\n    return _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.AddressType.P2PK;\n  } else if (ergoTree.length === P2SH_ERGOTREE_LENGTH && (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.startsWith)(ergoTree, P2SH_ERGOTREE_PREFIX) && (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.endsWith)(ergoTree, P2SH_ERGOTREE_SUFFIX)) {\n    return _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.AddressType.P2SH;\n  } else {\n    return _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.AddressType.P2S;\n  }\n}\nfunction _validateCompressedEcPoint(pointBytes) {\n  if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(pointBytes) || pointBytes.length !== 33) {\n    return false;\n  }\n  return pointBytes[0] === 2 || pointBytes[0] === 3;\n}\nvar ErgoAddress = class _ErgoAddress {\n  _ergoTree;\n  _network;\n  _type;\n  get network() {\n    return this._network;\n  }\n  /**\n   * ErgoTree hex string\n   */\n  get ergoTree() {\n    return _fleet_sdk_crypto__WEBPACK_IMPORTED_MODULE_2__.hex.encode(this._ergoTree);\n  }\n  get type() {\n    return this._type;\n  }\n  /**\n   * New instance from ErgoTree bytes\n   * @param ergoTree ErgoTree bytes\n   */\n  constructor(ergoTree, network) {\n    this._ergoTree = ergoTree;\n    this._network = network;\n    this._type = _getErgoTreeType(ergoTree);\n  }\n  /**\n   * Create a new instance from an ErgoTree\n   * @param ergoTree ErgoTree hex string\n   */\n  static fromErgoTree(ergoTree, network) {\n    return new _ErgoAddress(_fleet_sdk_crypto__WEBPACK_IMPORTED_MODULE_2__.hex.decode(ergoTree), network);\n  }\n  /**\n   * Create a new instance from a public key\n   * @param publicKey Public key hex string\n   */\n  static fromPublicKey(publicKey, network) {\n    const bytes = _ensureBytes(publicKey);\n    if (!_validateCompressedEcPoint(bytes)) {\n      throw new Error(\"The Public Key is invalid.\");\n    }\n    const ergoTree = (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(P2PK_ERGOTREE_PREFIX, bytes);\n    return new _ErgoAddress(ergoTree, network);\n  }\n  static fromHash(hash, network) {\n    hash = _ensureBytes(hash);\n    if (hash.length === BLAKE_256_HASH_LENGTH) {\n      hash = hash.subarray(0, P2SH_HASH_LENGTH);\n    } else if (hash.length != P2SH_HASH_LENGTH) {\n      throw Error(`Invalid hash length: ${hash.length}`);\n    }\n    const ergoTree = (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(P2SH_ERGOTREE_PREFIX, hash, P2SH_ERGOTREE_SUFFIX);\n    return new _ErgoAddress(ergoTree, network);\n  }\n  /**\n   * Create a new checked instance from an address string\n   * @param encodedAddress Address encoded as base58\n   */\n  static fromBase58(encodedAddress, skipCheck = false) {\n    const bytes = _fleet_sdk_crypto__WEBPACK_IMPORTED_MODULE_2__.base58.decode(encodedAddress);\n    if (!skipCheck && !_ErgoAddress.validate(bytes)) {\n      throw new InvalidAddress(encodedAddress);\n    }\n    const network = _getEncodedNetworkType(bytes);\n    const type = _getEncodedAddressType(bytes);\n    const body = bytes.subarray(1, bytes.length - CHECKSUM_LENGTH);\n    if (type === _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.AddressType.P2PK) {\n      return this.fromPublicKey(body, network);\n    } else if (type === _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.AddressType.P2SH) {\n      return this.fromHash(body, network);\n    } else {\n      return new _ErgoAddress(body, network);\n    }\n  }\n  /**\n   * Validate an address\n   * @param address Address bytes or string\n   */\n  static validate(address) {\n    const bytes = typeof address === \"string\" ? _fleet_sdk_crypto__WEBPACK_IMPORTED_MODULE_2__.base58.decode(address) : address;\n    if (bytes.length < CHECKSUM_LENGTH) {\n      return false;\n    }\n    if (_getEncodedAddressType(bytes) === _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.AddressType.P2PK) {\n      const pk = bytes.subarray(1, bytes.length - CHECKSUM_LENGTH);\n      if (!_validateCompressedEcPoint(pk)) {\n        return false;\n      }\n    }\n    const script = bytes.subarray(0, bytes.length - CHECKSUM_LENGTH);\n    const checksum = bytes.subarray(bytes.length - CHECKSUM_LENGTH, bytes.length);\n    const blakeHash = (0,_fleet_sdk_crypto__WEBPACK_IMPORTED_MODULE_2__.blake2b256)(script);\n    const calculatedChecksum = blakeHash.subarray(0, CHECKSUM_LENGTH);\n    return (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.areEqual)(calculatedChecksum, checksum);\n  }\n  static getNetworkType(address) {\n    return _getEncodedNetworkType(_fleet_sdk_crypto__WEBPACK_IMPORTED_MODULE_2__.base58.decode(address));\n  }\n  static getAddressType(address) {\n    return _getEncodedAddressType(_fleet_sdk_crypto__WEBPACK_IMPORTED_MODULE_2__.base58.decode(address));\n  }\n  getPublicKeys() {\n    if (this.type === _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.AddressType.P2PK) {\n      return [this._ergoTree.subarray(P2PK_ERGOTREE_PREFIX.length)];\n    }\n    return [];\n  }\n  toP2SH(network) {\n    if (this.type === _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.AddressType.P2SH) {\n      return this.encode();\n    }\n    const hash = (0,_fleet_sdk_crypto__WEBPACK_IMPORTED_MODULE_2__.blake2b256)(this._ergoTree).subarray(0, P2SH_HASH_LENGTH);\n    return this._encode(hash, _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.AddressType.P2SH, network);\n  }\n  /**\n   * Encode address as base58 string\n   */\n  encode(network) {\n    let body;\n    if (this.type === _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.AddressType.P2PK) {\n      body = (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.first)(this.getPublicKeys());\n    } else if (this.type === _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.AddressType.P2SH) {\n      body = this._ergoTree.subarray(\n        P2SH_ERGOTREE_PREFIX.length,\n        P2SH_ERGOTREE_PREFIX.length + P2SH_HASH_LENGTH\n      );\n    } else {\n      body = this._ergoTree;\n    }\n    return this._encode(body, this.type, network);\n  }\n  _encode(body, type, network) {\n    if (!(0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isDefined)(network)) {\n      if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isDefined)(this.network)) {\n        network = this.network;\n      } else {\n        network = _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.Network.Mainnet;\n      }\n    }\n    const head = Uint8Array.from([network + type]);\n    body = (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(head, body);\n    const checksum = (0,_fleet_sdk_crypto__WEBPACK_IMPORTED_MODULE_2__.blake2b256)(body).subarray(0, CHECKSUM_LENGTH);\n    return _fleet_sdk_crypto__WEBPACK_IMPORTED_MODULE_2__.base58.encode((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(body, checksum));\n  }\n  /**\n   * Encode address as base58 string\n   */\n  toString(network) {\n    return this.encode(network);\n  }\n};\nvar ErgoBox = class _ErgoBox {\n  boxId;\n  value;\n  ergoTree;\n  creationHeight;\n  assets;\n  additionalRegisters;\n  transactionId;\n  index;\n  constructor(box) {\n    this.boxId = box.boxId;\n    this.ergoTree = box.ergoTree;\n    this.creationHeight = box.creationHeight;\n    this.value = (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.ensureBigInt)(box.value);\n    this.assets = box.assets.map((asset) => ({\n      tokenId: asset.tokenId,\n      amount: (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.ensureBigInt)(asset.amount)\n    }));\n    this.additionalRegisters = box.additionalRegisters;\n    this.transactionId = box.transactionId;\n    this.index = box.index;\n  }\n  isValid() {\n    return _ErgoBox.validate(this);\n  }\n  static validate(box) {\n    const bytes = (0,_fleet_sdk_serializer__WEBPACK_IMPORTED_MODULE_1__.serializeBox)(box).toBytes();\n    const hash = _fleet_sdk_crypto__WEBPACK_IMPORTED_MODULE_2__.hex.encode((0,_fleet_sdk_crypto__WEBPACK_IMPORTED_MODULE_2__.blake2b256)(bytes));\n    return box.boxId === hash;\n  }\n};\n\n// src/models/ergoUnsignedInput.ts\nvar ErgoUnsignedInput = class extends ErgoBox {\n  #extension;\n  get extension() {\n    return this.#extension;\n  }\n  constructor(box) {\n    super(box);\n    if (box.extension) {\n      this.setContextVars(box.extension);\n    }\n  }\n  setContextExtension(extension) {\n    const vars = {};\n    for (const key in extension) {\n      const c = extension[key];\n      if (!c)\n        continue;\n      vars[key] = typeof c === \"string\" ? c : c.toHex();\n    }\n    this.#extension = vars;\n    return this;\n  }\n  /**\n   * @deprecated use `setContextExtension` instead.\n   */\n  setContextVars(extension) {\n    return this.setContextExtension(extension);\n  }\n  toUnsignedInputObject(type) {\n    return {\n      ...this.toPlainObject(type),\n      extension: this.#extension || {}\n    };\n  }\n  toPlainObject(type) {\n    if (type === \"EIP-12\") {\n      return {\n        boxId: this.boxId,\n        value: this.value.toString(),\n        ergoTree: this.ergoTree,\n        creationHeight: this.creationHeight,\n        assets: this.assets.map((asset) => ({\n          tokenId: asset.tokenId,\n          amount: asset.amount.toString()\n        })),\n        additionalRegisters: this.additionalRegisters,\n        transactionId: this.transactionId,\n        index: this.index\n      };\n    } else {\n      return {\n        boxId: this.boxId\n      };\n    }\n  }\n};\nvar ErgoUnsignedTransaction = class {\n  _inputs;\n  _dataInputs;\n  _outputs;\n  constructor(inputs, dataInputs, outputs) {\n    this._inputs = Object.freeze(inputs);\n    this._dataInputs = Object.freeze(dataInputs);\n    this._outputs = Object.freeze(outputs);\n  }\n  get id() {\n    return _fleet_sdk_crypto__WEBPACK_IMPORTED_MODULE_2__.hex.encode((0,_fleet_sdk_crypto__WEBPACK_IMPORTED_MODULE_2__.blake2b256)(this.toBytes()));\n  }\n  get inputs() {\n    return this._inputs;\n  }\n  get dataInputs() {\n    return this._dataInputs;\n  }\n  get outputs() {\n    return this._outputs;\n  }\n  get burning() {\n    return (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.utxoDiff)((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.utxoSum)(this.inputs), (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.utxoSum)(this.outputs));\n  }\n  toPlainObject(outputType) {\n    return {\n      inputs: this.inputs.map((input) => input.toUnsignedInputObject(outputType || \"default\")),\n      dataInputs: this.dataInputs.map((input) => input.toPlainObject(outputType || \"default\")),\n      outputs: this.outputs.map((output) => _stringifyBoxAmounts(output))\n    };\n  }\n  toEIP12Object() {\n    return this.toPlainObject(\"EIP-12\");\n  }\n  toBytes() {\n    return (0,_fleet_sdk_serializer__WEBPACK_IMPORTED_MODULE_1__.serializeTransaction)({\n      inputs: this.inputs.map((input) => input.toUnsignedInputObject(\"default\")),\n      dataInputs: this.dataInputs.map((input) => input.toPlainObject(\"default\")),\n      outputs: this.outputs\n    }).toBytes();\n  }\n};\nfunction _stringifyBoxAmounts(output) {\n  return {\n    ...output,\n    value: output.value.toString(),\n    assets: output.assets.map((token) => ({\n      tokenId: token.tokenId,\n      amount: token.amount.toString()\n    }))\n  };\n}\nvar InputsCollection = class extends _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.Collection {\n  constructor(boxes) {\n    super();\n    if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isDefined)(boxes)) {\n      this.add(boxes);\n    }\n  }\n  _map(input) {\n    return input instanceof ErgoUnsignedInput ? input : new ErgoUnsignedInput(input);\n  }\n  _addOne(box) {\n    if (this._items.some((item) => item.boxId === box.boxId)) {\n      throw new DuplicateInputError(box.boxId);\n    }\n    return super._addOne(box);\n  }\n  remove(boxIdOrIndex) {\n    let index = -1;\n    if (typeof boxIdOrIndex === \"number\") {\n      if (this._isIndexOutOfBounds(boxIdOrIndex)) {\n        throw new RangeError(`Index '${boxIdOrIndex}' is out of range.`);\n      }\n      index = boxIdOrIndex;\n    } else {\n      index = this._items.findIndex((box) => box.boxId === boxIdOrIndex);\n      if (this._isIndexOutOfBounds(index)) {\n        throw new NotFoundError(\n          \"The input you are trying to remove is not present in the inputs collection.\"\n        );\n      }\n    }\n    this._items.splice(index, 1);\n    return this.length;\n  }\n};\nfunction setsum(map, key, value) {\n  return map.set(key, (map.get(key) || _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._0n) + value);\n}\nvar OutputsCollection = class _OutputsCollection extends _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.Collection {\n  constructor(outputs) {\n    super();\n    if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isDefined)(outputs)) {\n      this.add(outputs);\n    }\n  }\n  _map(output) {\n    return output;\n  }\n  remove(outputs) {\n    let index = -1;\n    if (typeof outputs === \"number\") {\n      if (this._isIndexOutOfBounds(outputs)) {\n        throw new RangeError(`Index '${outputs}' is out of range.`);\n      }\n      index = outputs;\n    } else {\n      index = this._items.lastIndexOf(outputs);\n      if (this._isIndexOutOfBounds(index)) {\n        throw new NotFoundError(\n          \"The output you are trying to remove is not present in the outputs collection.\"\n        );\n      }\n    }\n    this._items.splice(index, 1);\n    return this.length;\n  }\n  clone() {\n    return new _OutputsCollection(this._items);\n  }\n  sum(basis) {\n    const tokens = /* @__PURE__ */ new Map();\n    let nanoErgs = _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._0n;\n    if (basis) {\n      if (basis.nanoErgs) {\n        nanoErgs = basis.nanoErgs;\n      }\n      if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.some)(basis.tokens)) {\n        for (const token of basis.tokens) {\n          if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(token.amount))\n            continue;\n          setsum(tokens, token.tokenId, token.amount);\n        }\n      }\n    }\n    for (const box of this._items) {\n      nanoErgs += box.value;\n      for (const token of box.assets) {\n        if (token.tokenId)\n          setsum(tokens, token.tokenId, token.amount);\n      }\n    }\n    return {\n      nanoErgs,\n      tokens: Array.from(tokens, ([tokenId, amount]) => ({ tokenId, amount }))\n    };\n  }\n};\nvar VERSION_MASK = 7;\nvar ErgoTree = class {\n  _bytes;\n  constructor(input) {\n    if (typeof input === \"string\") {\n      this._bytes = _fleet_sdk_crypto__WEBPACK_IMPORTED_MODULE_2__.hex.decode(input);\n    } else {\n      this._bytes = input;\n    }\n  }\n  get header() {\n    return this._bytes[0];\n  }\n  get version() {\n    return this.header & VERSION_MASK;\n  }\n  get hasSegregatedConstants() {\n    return (this.header & _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.ergoTreeHeaderFlags.constantSegregation) != 0;\n  }\n  get hasSize() {\n    return (this.header & _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.ergoTreeHeaderFlags.sizeInclusion) != 0;\n  }\n  toBytes() {\n    return this._bytes;\n  }\n  toHex() {\n    return _fleet_sdk_crypto__WEBPACK_IMPORTED_MODULE_2__.hex.encode(this.toBytes());\n  }\n  toAddress(network = _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.Network.Mainnet) {\n    return ErgoAddress.fromErgoTree(this.toHex(), network);\n  }\n};\n\n// src/builder/outputBuilder.ts\nvar BOX_VALUE_PER_BYTE = BigInt(360);\nvar SAFE_MIN_BOX_VALUE = BigInt(1e6);\nfunction estimateMinBoxValue(valuePerByte = BOX_VALUE_PER_BYTE) {\n  return (output) => {\n    return BigInt(output.estimateSize()) * valuePerByte;\n  };\n}\nvar DUMB_TOKEN_ID = \"0000000000000000000000000000000000000000000000000000000000000000\";\nvar OutputBuilder = class {\n  _address;\n  _tokens;\n  _value;\n  _valueEstimator;\n  _creationHeight;\n  _registers;\n  constructor(value, recipient, creationHeight) {\n    this.setValue(value);\n    this._creationHeight = creationHeight;\n    this._tokens = new TokensCollection();\n    this._registers = {};\n    if (typeof recipient === \"string\") {\n      this._address = (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isHex)(recipient) ? ErgoAddress.fromErgoTree(recipient) : ErgoAddress.fromBase58(recipient);\n    } else if (recipient instanceof ErgoTree) {\n      this._address = recipient.toAddress();\n    } else {\n      this._address = recipient;\n    }\n  }\n  get value() {\n    return (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isDefined)(this._valueEstimator) ? this._valueEstimator(this) : this._value;\n  }\n  get address() {\n    return this._address;\n  }\n  get ergoTree() {\n    return this._address.ergoTree;\n  }\n  get creationHeight() {\n    return this._creationHeight;\n  }\n  get assets() {\n    return this._tokens;\n  }\n  get additionalRegisters() {\n    return this._registers;\n  }\n  get minting() {\n    return this.assets.minting;\n  }\n  setValue(value) {\n    if (typeof value === \"function\") {\n      this._valueEstimator = value;\n    } else {\n      this._value = (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.ensureBigInt)(value);\n      this._valueEstimator = void 0;\n      if (this._value <= _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._0n) {\n        throw new Error(\"An UTxO cannot be created without a minimum required amount.\");\n      }\n    }\n    return this;\n  }\n  addTokens(tokens, options) {\n    if (tokens instanceof TokensCollection) {\n      this._tokens.add(tokens.toArray(), options);\n    } else {\n      this._tokens.add(tokens, options);\n    }\n    return this;\n  }\n  addNfts(...tokenIds) {\n    const tokens = tokenIds.map((tokenId) => ({ tokenId, amount: _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._1n }));\n    return this.addTokens(tokens);\n  }\n  mintToken(token) {\n    this.assets.mint(token);\n    return this;\n  }\n  setCreationHeight(height, options) {\n    if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(options) || options.replace === true || options.replace === false && (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(this._creationHeight)) {\n      this._creationHeight = height;\n    }\n    return this;\n  }\n  setAdditionalRegisters(registers) {\n    const hexRegisters = {};\n    for (const key in registers) {\n      const r = registers[key];\n      if (!r)\n        continue;\n      hexRegisters[key] = typeof r === \"string\" ? r : r.toHex();\n    }\n    if (!(0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.areRegistersDenselyPacked)(hexRegisters))\n      throw new InvalidRegistersPacking();\n    this._registers = hexRegisters;\n    return this;\n  }\n  eject(ejector) {\n    ejector({ tokens: this._tokens });\n    return this;\n  }\n  build(transactionInputs) {\n    let tokens;\n    if (this.minting) {\n      const mintingTokenId = transactionInputs ? transactionInputs[0]?.boxId : void 0;\n      tokens = this.assets.toArray(mintingTokenId);\n      if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(this.additionalRegisters)) {\n        this.setAdditionalRegisters({\n          R4: (0,_fleet_sdk_serializer__WEBPACK_IMPORTED_MODULE_1__.SColl)(_fleet_sdk_serializer__WEBPACK_IMPORTED_MODULE_1__.SByte, _fleet_sdk_crypto__WEBPACK_IMPORTED_MODULE_2__.utf8.decode(this.minting.name || \"\")),\n          R5: (0,_fleet_sdk_serializer__WEBPACK_IMPORTED_MODULE_1__.SColl)(_fleet_sdk_serializer__WEBPACK_IMPORTED_MODULE_1__.SByte, _fleet_sdk_crypto__WEBPACK_IMPORTED_MODULE_2__.utf8.decode(this.minting.description || \"\")),\n          R6: (0,_fleet_sdk_serializer__WEBPACK_IMPORTED_MODULE_1__.SColl)(_fleet_sdk_serializer__WEBPACK_IMPORTED_MODULE_1__.SByte, _fleet_sdk_crypto__WEBPACK_IMPORTED_MODULE_2__.utf8.decode(this.minting.decimals?.toString() || \"0\"))\n        });\n      }\n    } else {\n      tokens = this.assets.toArray();\n    }\n    if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(this.creationHeight))\n      throw new UndefinedCreationHeight();\n    return {\n      value: this.value,\n      ergoTree: this.ergoTree,\n      creationHeight: this.creationHeight,\n      assets: tokens,\n      additionalRegisters: this.additionalRegisters\n    };\n  }\n  estimateSize(value = SAFE_MIN_BOX_VALUE) {\n    (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.assert)(!!this.creationHeight, \"Creation height must be set\");\n    const plainBoxObject = {\n      value,\n      ergoTree: this.ergoTree,\n      creationHeight: this.creationHeight,\n      assets: this._tokens.toArray(DUMB_TOKEN_ID),\n      additionalRegisters: this.additionalRegisters\n    };\n    return (0,_fleet_sdk_serializer__WEBPACK_IMPORTED_MODULE_1__.estimateBoxSize)(plainBoxObject);\n  }\n};\n\n// src/errors/nonStandardizedMinting.ts\nvar NonStandardizedMinting = class extends Error {\n  constructor(message) {\n    super(message);\n  }\n};\n\n// src/builder/pluginContext.ts\nfunction createPluginContext(transactionBuilder) {\n  return {\n    addInputs: (inputs) => transactionBuilder.from(inputs).configureSelector(\n      (selector) => selector.ensureInclusion(\n        Array.isArray(inputs) ? inputs.map((input) => input.boxId) : inputs.boxId\n      )\n    ).inputs.length,\n    addOutputs: (outputs, options) => transactionBuilder.to(outputs, options).outputs.length,\n    addDataInputs: (dataInputs, options) => transactionBuilder.withDataFrom(dataInputs, options).dataInputs.length,\n    burnTokens: (tokens) => {\n      if (!transactionBuilder.settings.canBurnTokensFromPlugins) {\n        throw new NotAllowedTokenBurning();\n      }\n      transactionBuilder.burnTokens(tokens);\n    },\n    setFee: (amount) => transactionBuilder.payFee(amount)\n  };\n}\n\n// src/builder/transactionBuilderSettings.ts\nvar TransactionBuilderSettings = class {\n  _maxDistinctTokensPerChangeBox;\n  _allowTokenBurning;\n  _allowTokenBurningFromPlugins;\n  _isolateErgOnChange;\n  constructor() {\n    this._maxDistinctTokensPerChangeBox = MAX_TOKENS_PER_BOX;\n    this._allowTokenBurning = false;\n    this._allowTokenBurningFromPlugins = false;\n    this._isolateErgOnChange = false;\n  }\n  get maxTokensPerChangeBox() {\n    return this._maxDistinctTokensPerChangeBox;\n  }\n  get canBurnTokens() {\n    return this._allowTokenBurning;\n  }\n  get canBurnTokensFromPlugins() {\n    return this.canBurnTokens || this._allowTokenBurningFromPlugins;\n  }\n  get shouldIsolateErgOnChange() {\n    return this._isolateErgOnChange;\n  }\n  /**\n   * Define max number of distinct tokens per change box\n   */\n  setMaxTokensPerChangeBox(max) {\n    this._maxDistinctTokensPerChangeBox = max;\n    return this;\n  }\n  /**\n   * Allows or denies token burning from all contexts\n   */\n  allowTokenBurning(allow = true) {\n    this._allowTokenBurning = allow;\n    return this;\n  }\n  /**\n   * Allows or denies token burning **only** from plugins context.\n   */\n  allowTokenBurningFromPlugins(allow = true) {\n    this._allowTokenBurningFromPlugins = allow;\n    return this;\n  }\n  /**\n   * If true, it creates an exclusive change box only for ERG.\n   * This setting is especially useful for Ledger devices to\n   * help on avoiding to hit the max tokens limit per transaction.\n   */\n  isolateErgOnChange(isolate = true) {\n    this._isolateErgOnChange = isolate;\n    return this;\n  }\n};\n\n// src/builder/transactionBuilder.ts\nvar RECOMMENDED_MIN_FEE_VALUE = BigInt(11e5);\nvar FEE_CONTRACT = \"1005040004000e36100204a00b08cd0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798ea02d192a39a8cc7a701730073011001020402d19683030193a38cc7b2a57300000193c2b2a57301007473027303830108cdeeac93b1a57304\";\nvar TransactionBuilder2 = class {\n  _inputs;\n  _dataInputs;\n  _outputs;\n  _settings;\n  _creationHeight;\n  _selectorCallbacks;\n  _changeAddress;\n  _feeAmount;\n  _burning;\n  _plugins;\n  constructor(creationHeight) {\n    this._inputs = new InputsCollection();\n    this._dataInputs = new InputsCollection();\n    this._outputs = new OutputsCollection();\n    this._settings = new TransactionBuilderSettings();\n    this._creationHeight = creationHeight;\n  }\n  get inputs() {\n    return this._inputs;\n  }\n  get dataInputs() {\n    return this._dataInputs;\n  }\n  get outputs() {\n    return this._outputs;\n  }\n  get changeAddress() {\n    return this._changeAddress;\n  }\n  get fee() {\n    return this._feeAmount;\n  }\n  get burning() {\n    return this._burning;\n  }\n  get settings() {\n    return this._settings;\n  }\n  get creationHeight() {\n    return this._creationHeight;\n  }\n  /**\n   * Syntax sugar to be used in composition with another methods\n   *\n   * @example\n   * ```\n   * new TransactionBuilder(height)\n   *   .from(inputs)\n   *   .and.from(otherInputs);\n   * ```\n   */\n  get and() {\n    return this;\n  }\n  from(inputs) {\n    if (isCollectionLike(inputs)) {\n      inputs = inputs.toArray();\n    }\n    this._inputs.add(inputs);\n    return this;\n  }\n  to(outputs, options) {\n    this._outputs.add(outputs, options);\n    return this;\n  }\n  withDataFrom(dataInputs, options) {\n    this._dataInputs.add(dataInputs, options);\n    return this;\n  }\n  sendChangeTo(address) {\n    if (typeof address === \"string\") {\n      this._changeAddress = (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isHex)(address) ? ErgoAddress.fromErgoTree(address, _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.Network.Mainnet) : ErgoAddress.fromBase58(address);\n    } else {\n      this._changeAddress = address;\n    }\n    return this;\n  }\n  payFee(amount) {\n    this._feeAmount = (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.ensureBigInt)(amount);\n    return this;\n  }\n  payMinFee() {\n    this.payFee(RECOMMENDED_MIN_FEE_VALUE);\n    return this;\n  }\n  burnTokens(tokens) {\n    if (!this._burning) {\n      this._burning = new TokensCollection();\n    }\n    this._burning.add(tokens);\n    return this;\n  }\n  configure(callback) {\n    callback(this._settings);\n    return this;\n  }\n  configureSelector(selectorCallback) {\n    if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(this._selectorCallbacks)) {\n      this._selectorCallbacks = [];\n    }\n    this._selectorCallbacks.push(selectorCallback);\n    return this;\n  }\n  extend(plugins) {\n    if (!this._plugins) {\n      this._plugins = [];\n    }\n    this._plugins.push({ execute: plugins, pending: true });\n    return this;\n  }\n  eject(ejector) {\n    ejector({\n      inputs: this.inputs,\n      dataInputs: this.dataInputs,\n      outputs: this.outputs,\n      burning: this.burning,\n      settings: this.settings,\n      selection: (selectorCallback) => {\n        this.configureSelector(selectorCallback);\n      }\n    });\n    return this;\n  }\n  build() {\n    if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.some)(this._plugins)) {\n      const context = createPluginContext(this);\n      for (const plugin of this._plugins) {\n        if (plugin.pending) {\n          plugin.execute(context);\n          plugin.pending = false;\n        }\n      }\n    }\n    if (this._isMinting()) {\n      if (this._isMoreThanOneTokenBeingMinted()) {\n        throw new MalformedTransaction(\"only one token can be minted per transaction.\");\n      }\n      if (this._isTheSameTokenBeingMintedFromOutsideTheMintingBox()) {\n        throw new NonStandardizedMinting(\n          \"EIP-4 tokens cannot be minted from outside of the minting box.\"\n        );\n      }\n    }\n    this.outputs.toArray().map((output) => output.setCreationHeight(this._creationHeight, { replace: false }));\n    const outputs = this.outputs.clone();\n    if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isDefined)(this._feeAmount)) {\n      outputs.add(new OutputBuilder(this._feeAmount, FEE_CONTRACT));\n    }\n    const selector = new BoxSelector(this.inputs.toArray());\n    if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.some)(this._selectorCallbacks)) {\n      for (const selectorCallBack of this._selectorCallbacks) {\n        selectorCallBack(selector);\n      }\n    }\n    const target = (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.some)(this._burning) ? outputs.sum({ tokens: this._burning.toArray() }) : outputs.sum();\n    let inputs = selector.select(target);\n    if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isDefined)(this._changeAddress)) {\n      let change = (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.utxoDiff)((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.utxoSum)(inputs), target);\n      const changeBoxes = [];\n      if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.some)(change.tokens)) {\n        let minRequiredNanoErgs = estimateMinChangeValue({\n          changeAddress: this._changeAddress,\n          creationHeight: this._creationHeight,\n          tokens: change.tokens,\n          maxTokensPerBox: this.settings.maxTokensPerChangeBox,\n          baseIndex: this.outputs.length + 1\n        });\n        while (minRequiredNanoErgs > change.nanoErgs) {\n          inputs = selector.select({\n            nanoErgs: target.nanoErgs + minRequiredNanoErgs,\n            tokens: target.tokens\n          });\n          change = (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.utxoDiff)((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.utxoSum)(inputs), target);\n          minRequiredNanoErgs = estimateMinChangeValue({\n            changeAddress: this._changeAddress,\n            creationHeight: this._creationHeight,\n            tokens: change.tokens,\n            maxTokensPerBox: this.settings.maxTokensPerChangeBox,\n            baseIndex: this.outputs.length + 1\n          });\n        }\n        const chunkedTokens = (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.chunk)(change.tokens, this._settings.maxTokensPerChangeBox);\n        for (const tokens of chunkedTokens) {\n          const output = new OutputBuilder(\n            estimateMinBoxValue(),\n            this._changeAddress,\n            this._creationHeight\n          ).addTokens(tokens);\n          change.nanoErgs -= output.value;\n          changeBoxes.push(output);\n        }\n      }\n      if (change.nanoErgs > _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._0n) {\n        if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.some)(changeBoxes)) {\n          if (this.settings.shouldIsolateErgOnChange) {\n            outputs.add(new OutputBuilder(change.nanoErgs, this._changeAddress));\n          } else {\n            const firstChangeBox = (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.first)(changeBoxes);\n            firstChangeBox.setValue(firstChangeBox.value + change.nanoErgs);\n          }\n          outputs.add(changeBoxes);\n        } else {\n          outputs.add(new OutputBuilder(change.nanoErgs, this._changeAddress));\n        }\n      }\n    }\n    for (const input of inputs) {\n      if (!input.isValid()) {\n        throw new InvalidInput(input.boxId);\n      }\n    }\n    const unsignedTransaction = new ErgoUnsignedTransaction(\n      inputs,\n      this.dataInputs.toArray(),\n      outputs.toArray().map(\n        (output) => output.setCreationHeight(this._creationHeight, { replace: false }).build(inputs)\n      )\n    );\n    let burning = unsignedTransaction.burning;\n    if (burning.nanoErgs > _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._0n) {\n      throw new MalformedTransaction(\"it's not possible to burn ERG.\");\n    }\n    if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.some)(burning.tokens) && (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.some)(this._burning)) {\n      burning = (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.utxoDiff)(burning, { nanoErgs: _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._0n, tokens: this._burning.toArray() });\n    }\n    if (!this._settings.canBurnTokens && (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.some)(burning.tokens)) {\n      throw new NotAllowedTokenBurning();\n    }\n    return unsignedTransaction;\n  }\n  _isMinting() {\n    for (const output of this._outputs) {\n      if (output.minting)\n        return true;\n    }\n    return false;\n  }\n  _isMoreThanOneTokenBeingMinted() {\n    let mintingCount = 0;\n    for (const output of this._outputs) {\n      if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isDefined)(output.minting)) {\n        mintingCount++;\n        if (mintingCount > 1)\n          return true;\n      }\n    }\n    return false;\n  }\n  _isTheSameTokenBeingMintedFromOutsideTheMintingBox() {\n    const mintingTokenId = this._getMintingTokenId();\n    if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(mintingTokenId))\n      return false;\n    let count = 0;\n    for (const output of this._outputs) {\n      if (output.assets.contains(mintingTokenId)) {\n        count++;\n        if (count > 1)\n          return true;\n      }\n    }\n    return false;\n  }\n  _getMintingTokenId() {\n    let tokenId = void 0;\n    for (const output of this._outputs) {\n      if (output.minting) {\n        tokenId = output.minting.tokenId;\n        break;\n      }\n    }\n    return tokenId;\n  }\n};\nfunction isCollectionLike(obj) {\n  return obj.toArray !== void 0;\n}\nfunction estimateMinChangeValue(params) {\n  const size = BigInt(estimateChangeSize(params));\n  return size * BOX_VALUE_PER_BYTE;\n}\nfunction estimateChangeSize({\n  changeAddress,\n  creationHeight,\n  tokens,\n  baseIndex,\n  maxTokensPerBox\n}) {\n  const neededBoxes = Math.ceil(tokens.length / maxTokensPerBox);\n  let size = 0;\n  size += (0,_fleet_sdk_serializer__WEBPACK_IMPORTED_MODULE_1__.estimateVLQSize)(SAFE_MIN_BOX_VALUE);\n  size += (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.byteSizeOf)(changeAddress.ergoTree);\n  size += (0,_fleet_sdk_serializer__WEBPACK_IMPORTED_MODULE_1__.estimateVLQSize)(creationHeight);\n  size += (0,_fleet_sdk_serializer__WEBPACK_IMPORTED_MODULE_1__.estimateVLQSize)(0);\n  size += 32;\n  size = size * neededBoxes;\n  for (let i = 0; i < neededBoxes; i++) {\n    size += (0,_fleet_sdk_serializer__WEBPACK_IMPORTED_MODULE_1__.estimateVLQSize)(baseIndex + i);\n  }\n  size += tokens.reduce(\n    (acc, curr) => acc += (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.byteSizeOf)(curr.tokenId) + (0,_fleet_sdk_serializer__WEBPACK_IMPORTED_MODULE_1__.estimateVLQSize)(curr.amount),\n    0\n  );\n  if (tokens.length > maxTokensPerBox) {\n    if (tokens.length % maxTokensPerBox > 0) {\n      size += (0,_fleet_sdk_serializer__WEBPACK_IMPORTED_MODULE_1__.estimateVLQSize)(maxTokensPerBox) * Math.floor(tokens.length / maxTokensPerBox);\n      size += (0,_fleet_sdk_serializer__WEBPACK_IMPORTED_MODULE_1__.estimateVLQSize)(tokens.length % maxTokensPerBox);\n    } else {\n      size += (0,_fleet_sdk_serializer__WEBPACK_IMPORTED_MODULE_1__.estimateVLQSize)(maxTokensPerBox) * neededBoxes;\n    }\n  } else {\n    size += (0,_fleet_sdk_serializer__WEBPACK_IMPORTED_MODULE_1__.estimateVLQSize)(tokens.length);\n  }\n  return size;\n}\nfunction SConstant2(constant) {\n  return constant.toHex();\n}\nfunction SParse(bytes) {\n  return _fleet_sdk_serializer__WEBPACK_IMPORTED_MODULE_1__.SConstant.from(bytes).data;\n}\n\n\n//# sourceMappingURL=out.js.map\n//# sourceMappingURL=index.mjs.map\n\n//# sourceURL=webpack://my-project/./node_modules/@fleet-sdk/core/dist/index.mjs?");

/***/ }),

/***/ "./node_modules/@fleet-sdk/core/node_modules/@fleet-sdk/common/dist/index.mjs":
/*!************************************************************************************!*\
  !*** ./node_modules/@fleet-sdk/core/node_modules/@fleet-sdk/common/dist/index.mjs ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressType: () => (/* binding */ AddressType),\n/* harmony export */   BlockchainProviderError: () => (/* binding */ BlockchainProviderError),\n/* harmony export */   Collection: () => (/* binding */ Collection),\n/* harmony export */   FleetError: () => (/* binding */ FleetError),\n/* harmony export */   Network: () => (/* binding */ Network),\n/* harmony export */   NotSupportedError: () => (/* binding */ NotSupportedError),\n/* harmony export */   _0n: () => (/* binding */ _0n),\n/* harmony export */   _10n: () => (/* binding */ _10n),\n/* harmony export */   _127n: () => (/* binding */ _127n),\n/* harmony export */   _128n: () => (/* binding */ _128n),\n/* harmony export */   _1n: () => (/* binding */ _1n),\n/* harmony export */   _63n: () => (/* binding */ _63n),\n/* harmony export */   _7n: () => (/* binding */ _7n),\n/* harmony export */   areEqual: () => (/* binding */ areEqual),\n/* harmony export */   areEqualBy: () => (/* binding */ areEqualBy),\n/* harmony export */   areRegistersDenselyPacked: () => (/* binding */ areRegistersDenselyPacked),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertInstanceOf: () => (/* binding */ assertInstanceOf),\n/* harmony export */   assertTypeOf: () => (/* binding */ assertTypeOf),\n/* harmony export */   at: () => (/* binding */ at),\n/* harmony export */   byteSizeOf: () => (/* binding */ byteSizeOf),\n/* harmony export */   chunk: () => (/* binding */ chunk),\n/* harmony export */   clearUndefined: () => (/* binding */ clearUndefined),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   decimalize: () => (/* binding */ decimalize),\n/* harmony export */   depthOf: () => (/* binding */ depthOf),\n/* harmony export */   endsWith: () => (/* binding */ endsWith),\n/* harmony export */   ensureBigInt: () => (/* binding */ ensureBigInt),\n/* harmony export */   ensureDefaults: () => (/* binding */ ensureDefaults),\n/* harmony export */   ensureUTxOBigInt: () => (/* binding */ ensureUTxOBigInt),\n/* harmony export */   ergoTreeHeaderFlags: () => (/* binding */ ergoTreeHeaderFlags),\n/* harmony export */   first: () => (/* binding */ first),\n/* harmony export */   hasDuplicates: () => (/* binding */ hasDuplicates),\n/* harmony export */   hasDuplicatesBy: () => (/* binding */ hasDuplicatesBy),\n/* harmony export */   hasKey: () => (/* binding */ hasKey),\n/* harmony export */   isDefined: () => (/* binding */ isDefined),\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty),\n/* harmony export */   isFalsy: () => (/* binding */ isFalsy),\n/* harmony export */   isHex: () => (/* binding */ isHex),\n/* harmony export */   isTruthy: () => (/* binding */ isTruthy),\n/* harmony export */   isUndefined: () => (/* binding */ isUndefined),\n/* harmony export */   last: () => (/* binding */ last),\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   orderBy: () => (/* binding */ orderBy),\n/* harmony export */   percent: () => (/* binding */ percent),\n/* harmony export */   some: () => (/* binding */ some),\n/* harmony export */   startsWith: () => (/* binding */ startsWith),\n/* harmony export */   sumBy: () => (/* binding */ sumBy),\n/* harmony export */   undecimalize: () => (/* binding */ undecimalize),\n/* harmony export */   uniq: () => (/* binding */ uniq),\n/* harmony export */   uniqBy: () => (/* binding */ uniqBy),\n/* harmony export */   utxoDiff: () => (/* binding */ utxoDiff),\n/* harmony export */   utxoFilter: () => (/* binding */ utxoFilter),\n/* harmony export */   utxoSum: () => (/* binding */ utxoSum)\n/* harmony export */ });\n// src/utils/assertions.ts\nfunction assert(condition, error) {\n  if (condition)\n    return;\n  let err = void 0;\n  switch (typeof error) {\n    case \"string\":\n      err = new Error(error);\n      break;\n    case \"function\":\n      err = new Error(error());\n      break;\n    default:\n      err = error;\n  }\n  throw err;\n}\nfunction assertTypeOf(obj, expected) {\n  const type = typeof obj;\n  if (type !== expected) {\n    throw new Error(`Expected an object of type '${expected}', got '${type}'.`);\n  }\n}\nvar toString = (value) => Object.prototype.toString.call(value);\nfunction getTypeName(value) {\n  if (value === null)\n    return \"null\";\n  const type = typeof value;\n  return type === \"object\" || type === \"function\" ? toString(value).slice(8, -1) : type;\n}\nfunction assertInstanceOf(obj, expected) {\n  const condition = obj instanceof expected;\n  if (!condition) {\n    throw new Error(`Expected an instance of '${expected.name}', got '${getTypeName(obj)}'.`);\n  }\n}\nfunction isEmpty(target) {\n  if (!target)\n    return true;\n  return Array.isArray(target) ? target.length === 0 : Object.keys(target).length === 0;\n}\nfunction some(target) {\n  return !isEmpty(target);\n}\nfunction isTruthy(value) {\n  return !!value;\n}\nfunction isFalsy(value) {\n  return !value;\n}\nfunction isUndefined(v) {\n  return v === void 0 || v === null || Number.isNaN(v);\n}\nfunction isDefined(v) {\n  return !isUndefined(v);\n}\nfunction hasKey(o, key) {\n  return Object.prototype.hasOwnProperty.call(o, key);\n}\n\n// src/utils/array.ts\nfunction first(array) {\n  if (!array)\n    return void 0;\n  assert(array.length > 0, \"Empty array.\");\n  return array[0];\n}\nfunction last(array) {\n  if (!array)\n    return void 0;\n  assert(array.length > 0, \"Empty array.\");\n  return at(array, -1);\n}\nfunction at(array, index) {\n  const len = array?.length;\n  if (!len)\n    return void 0;\n  if (index < 0) {\n    index += len;\n  }\n  return array[index];\n}\nfunction hasDuplicates(array) {\n  return array.some((item, index) => {\n    return array.indexOf(item) !== index;\n  });\n}\nfunction hasDuplicatesBy(array, selector) {\n  return array.some((item, index) => {\n    return array.findIndex((x) => selector(x) === selector(item)) !== index;\n  });\n}\nfunction chunk(array, size) {\n  if (array.length <= size) {\n    return [array];\n  }\n  const chunks = [];\n  for (let i = 0; i < array.length; i += size) {\n    chunks.push(array.slice(i, i + size));\n  }\n  return chunks;\n}\nfunction orderBy(array, iteratee, order = \"asc\") {\n  return [...array].sort((a, b) => {\n    if (iteratee(a) > iteratee(b)) {\n      return order === \"asc\" ? 1 : -1;\n    } else if (iteratee(a) < iteratee(b)) {\n      return order === \"asc\" ? -1 : 1;\n    } else {\n      return 0;\n    }\n  });\n}\nfunction areEqual(array1, array2) {\n  if (array1 === array2) {\n    return true;\n  }\n  if (array1.length != array2.length) {\n    return false;\n  }\n  for (let i = 0; i < array1.length; i++) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction areEqualBy(array1, array2, selector) {\n  if (array1 === array2) {\n    return true;\n  }\n  if (array1.length != array2.length) {\n    return false;\n  }\n  for (let i = 0; i < array1.length; i++) {\n    if (selector(array1[i]) !== selector(array2[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction startsWith(array, target) {\n  if (array === target) {\n    return true;\n  }\n  if (target.length > array.length) {\n    return false;\n  }\n  for (let i = 0; i < target.length; i++) {\n    if (target[i] !== array[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction endsWith(array, target) {\n  if (array === target) {\n    return true;\n  }\n  if (target.length > array.length) {\n    return false;\n  }\n  const offset = array.length - target.length;\n  for (let i = target.length - 1; i >= 0; i--) {\n    if (target[i] !== array[i + offset]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction uniq(array) {\n  if (isEmpty(array)) {\n    return array;\n  }\n  return Array.from(new Set(array));\n}\nfunction uniqBy(array, selector, selection = \"keep-first\") {\n  if (isEmpty(array)) {\n    return array;\n  }\n  return Array.from(\n    array.reduce((map, e) => {\n      const key = selector(e);\n      if (selection === \"keep-first\" && map.has(key)) {\n        return map;\n      }\n      return map.set(key, e);\n    }, /* @__PURE__ */ new Map()).values()\n  );\n}\nfunction depthOf(array) {\n  return Array.isArray(array) ? 1 + Math.max(0, ...array.map(depthOf)) : 0;\n}\n\n// src/utils/bigInt.ts\nvar _0n = BigInt(0);\nvar _1n = BigInt(1);\nvar _7n = BigInt(7);\nvar _10n = BigInt(10);\nvar _63n = BigInt(63);\nvar _127n = BigInt(127);\nvar _128n = BigInt(128);\nfunction ensureBigInt(number) {\n  return typeof number === \"bigint\" ? number : BigInt(number);\n}\nfunction undecimalize(decimalStr, options) {\n  if (!decimalStr) {\n    return _0n;\n  }\n  options = typeof options == \"number\" ? { decimals: options } : options;\n  if (isUndefined(options)) {\n    options = {};\n  }\n  options.decimals = options.decimals || 0;\n  options.decimalMark = options.decimalMark || \".\";\n  const fragments = decimalStr.split(options.decimalMark);\n  if (fragments.length > 2) {\n    throw new Error(\"Invalid numeric string.\");\n  }\n  let [integer, decimal] = fragments;\n  integer = _removeLeadingZeros(integer);\n  const negative = integer.startsWith(\"-\") ? \"-\" : \"\";\n  if (!decimal) {\n    decimal = \"0\".repeat(options.decimals);\n  } else if (decimal.length < options.decimals) {\n    decimal = decimal.padEnd(options.decimals, \"0\");\n  }\n  return BigInt(negative + _stripNonDigits(integer + decimal));\n}\nfunction _stripNonDigits(value) {\n  return value.replace(/\\D/g, \"\");\n}\nfunction decimalize(value, options) {\n  value = ensureBigInt(value);\n  if (!options) {\n    return value.toString();\n  }\n  options = typeof options == \"number\" ? { decimals: options } : options;\n  options.decimals = options.decimals || 0;\n  options.decimalMark = options.decimalMark || \".\";\n  const pow = _10n ** BigInt(options.decimals);\n  const integer = value / pow;\n  const decimal = value - integer * pow;\n  return _buildFormattedDecimal(integer.toString(10), decimal.toString(10), options);\n}\nfunction percent(value, percentage, precision = 2n) {\n  return value * percentage / 10n ** precision;\n}\nfunction _buildFormattedDecimal(integer, decimal, options) {\n  const integerPart = _addThousandMarks(integer, options.thousandMark);\n  const decimalPart = _stripTrailingZeros(decimal.padStart(options.decimals, \"0\"));\n  if (decimalPart) {\n    return `${integerPart}${options.decimalMark}${decimalPart}`;\n  } else {\n    return integerPart;\n  }\n}\nfunction _addThousandMarks(value, mark) {\n  if (!mark) {\n    return value;\n  }\n  return value.replace(/\\B(?=(\\d{3})+(?!\\d))/g, mark);\n}\nfunction _stripTrailingZeros(value) {\n  if (!value.endsWith(\"0\")) {\n    return value;\n  }\n  return value.replace(/\\.?0+$/, \"\");\n}\nfunction _removeLeadingZeros(value) {\n  if (!value.startsWith(\"0\")) {\n    return value;\n  }\n  return value.replace(/^0+\\.?/, \"\");\n}\nfunction sumBy(collection, iteratee, condition) {\n  let acc = _0n;\n  if (isEmpty(collection)) {\n    return acc;\n  }\n  for (const item of collection) {\n    if (isUndefined(condition) || condition(item)) {\n      acc += iteratee(item);\n    }\n  }\n  return acc;\n}\nfunction min(...numbers) {\n  let min2 = first(numbers);\n  for (const num of numbers) {\n    if (num < min2) {\n      min2 = num;\n    }\n  }\n  return min2;\n}\nfunction max(...numbers) {\n  let max2 = first(numbers);\n  for (const num of numbers) {\n    if (num > max2) {\n      max2 = num;\n    }\n  }\n  return max2;\n}\n\n// src/utils/utxo.ts\nvar NANOERGS_TOKEN_ID = \"nanoErgs\";\nfunction utxoSum(boxes, tokenId) {\n  const balances = {};\n  for (const box of boxes) {\n    if (isUndefined(tokenId) || tokenId === NANOERGS_TOKEN_ID) {\n      balances[NANOERGS_TOKEN_ID] = (balances[NANOERGS_TOKEN_ID] || _0n) + ensureBigInt(box.value);\n    }\n    if (tokenId !== NANOERGS_TOKEN_ID) {\n      for (const token of box.assets) {\n        if (isDefined(tokenId) && tokenId !== token.tokenId) {\n          continue;\n        }\n        balances[token.tokenId] = (balances[token.tokenId] || _0n) + ensureBigInt(token.amount);\n      }\n    }\n  }\n  if (isDefined(tokenId)) {\n    return balances[tokenId] || _0n;\n  }\n  return {\n    nanoErgs: balances[NANOERGS_TOKEN_ID] || _0n,\n    tokens: Object.keys(balances).filter((x) => x !== NANOERGS_TOKEN_ID).map((tokenId2) => ({ tokenId: tokenId2, amount: balances[tokenId2] }))\n  };\n}\nfunction utxoDiff(minuend, subtrahend) {\n  if (Array.isArray(minuend)) {\n    minuend = utxoSum(minuend);\n  }\n  if (Array.isArray(subtrahend)) {\n    subtrahend = utxoSum(subtrahend);\n  }\n  const tokens = [];\n  const nanoErgs = minuend.nanoErgs - subtrahend.nanoErgs;\n  for (const token of minuend.tokens) {\n    const balance = token.amount - (subtrahend.tokens.find((t) => t.tokenId === token.tokenId)?.amount || _0n);\n    if (balance !== _0n) {\n      tokens.push({ tokenId: token.tokenId, amount: balance });\n    }\n  }\n  return { nanoErgs, tokens };\n}\nvar MIN_NON_MANDATORY_REGISTER_INDEX = 4;\nvar MAX_NON_MANDATORY_REGISTER_INDEX = 9;\nfunction areRegistersDenselyPacked(registers) {\n  let lastIndex = 0;\n  for (let i = MIN_NON_MANDATORY_REGISTER_INDEX; i <= MAX_NON_MANDATORY_REGISTER_INDEX; i++) {\n    const key = `R${i}`;\n    if (registers[key]) {\n      if (i === MIN_NON_MANDATORY_REGISTER_INDEX) {\n        lastIndex = i;\n        continue;\n      }\n      if (i - lastIndex > 1) {\n        return false;\n      }\n      lastIndex = i;\n    }\n  }\n  return true;\n}\nfunction utxoFilter(utxos, filterParams) {\n  if (isEmpty(filterParams) || isEmpty(utxos)) {\n    return utxos;\n  }\n  const { by, max: max2 } = filterParams;\n  let filtered = utxos;\n  if (by) {\n    filtered = utxos.filter(by);\n    if (isEmpty(filtered)) {\n      return filtered;\n    }\n  }\n  if (!max2) {\n    return filtered;\n  }\n  if (isDefined(max2.aggregatedDistinctTokens)) {\n    const tokenIds = _getDistinctTokenIds(filtered, max2.aggregatedDistinctTokens);\n    filtered = filtered.filter(\n      (utxo) => isEmpty(utxo.assets) || utxo.assets.every((token) => tokenIds.has(token.tokenId))\n    );\n  }\n  if (isDefined(max2.count) && filtered.length > max2.count) {\n    filtered = filtered.slice(0, max2.count);\n  }\n  return filtered;\n}\nfunction _getDistinctTokenIds(utxos, max2) {\n  const tokenIds = /* @__PURE__ */ new Set();\n  for (let i = 0; i < utxos.length && tokenIds.size < max2; i++) {\n    if (isEmpty(utxos[i].assets) || utxos[i].assets.length > max2) {\n      continue;\n    }\n    for (const token of utxos[i].assets) {\n      tokenIds.add(token.tokenId);\n    }\n  }\n  return tokenIds;\n}\nfunction ensureUTxOBigInt(box) {\n  return {\n    ...box,\n    value: ensureBigInt(box.value),\n    assets: box.assets.map((token) => ({\n      tokenId: token.tokenId,\n      amount: ensureBigInt(token.amount)\n    }))\n  };\n}\n\n// src/utils/object.ts\nfunction clearUndefined(value) {\n  const result = {};\n  for (const key in value) {\n    const val = value[key];\n    if (!isUndefined(val)) {\n      result[key] = val;\n    }\n  }\n  return result;\n}\nfunction ensureDefaults(options, defaults) {\n  return isEmpty(options) ? defaults : { ...defaults, ...options };\n}\n\n// src/utils/bytes.ts\nfunction concatBytes(...arrays) {\n  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n  let pad = 0;\n  for (const bytes of arrays) {\n    assertInstanceOf(bytes, Uint8Array);\n    r.set(bytes, pad);\n    pad += bytes.length;\n  }\n  return r;\n}\nfunction isHex(value) {\n  if (!value || value.length % 2)\n    return false;\n  if (!value.startsWith(\"0x\")) {\n    value = \"0x\" + value;\n  }\n  return !isNaN(Number(value));\n}\nfunction byteSizeOf(hex) {\n  return hex.length / 2;\n}\n\n// src/types/common.ts\nvar Network = /* @__PURE__ */ ((Network2) => {\n  Network2[Network2[\"Mainnet\"] = 0] = \"Mainnet\";\n  Network2[Network2[\"Testnet\"] = 16] = \"Testnet\";\n  return Network2;\n})(Network || {});\nvar AddressType = /* @__PURE__ */ ((AddressType2) => {\n  AddressType2[AddressType2[\"P2PK\"] = 1] = \"P2PK\";\n  AddressType2[AddressType2[\"P2SH\"] = 2] = \"P2SH\";\n  AddressType2[AddressType2[\"P2S\"] = 3] = \"P2S\";\n  return AddressType2;\n})(AddressType || {});\nvar ergoTreeHeaderFlags = {\n  sizeInclusion: 8,\n  constantSegregation: 16\n};\n\n// src/models/collection.ts\nvar Collection = class {\n  _items;\n  constructor() {\n    this._items = [];\n  }\n  _isIndexOutOfBounds(index) {\n    return index < 0 || index >= this._items.length;\n  }\n  [Symbol.iterator]() {\n    let counter = 0;\n    return {\n      next: () => {\n        return {\n          done: counter >= this.length,\n          value: this._items[counter++]\n        };\n      }\n    };\n  }\n  /**\n   * Number of items in the collection\n   */\n  get length() {\n    return this._items.length;\n  }\n  /**\n   * True if the collection is empty\n   */\n  get isEmpty() {\n    return this.length === 0;\n  }\n  /**\n   * Get item at index\n   * @param index\n   * @throws RangeError if index is out of bounds\n   */\n  at(index) {\n    if (this._isIndexOutOfBounds(index)) {\n      throw new RangeError(`Index '${index}' is out of range.`);\n    }\n    return this._items[index];\n  }\n  /**\n   * Add item to the collection\n   * @param items\n   * @param options\n   * @returns The new length of the collection\n   */\n  add(items, options) {\n    return this._addOneOrMore(items, options);\n  }\n  _addOne(item, options) {\n    if (isDefined(options) && isDefined(options.index)) {\n      if (options.index === this.length) {\n        this._items.push(this._map(item));\n        return this.length;\n      }\n      if (this._isIndexOutOfBounds(options.index)) {\n        throw new RangeError(`Index '${options.index}' is out of range.`);\n      }\n      this._items.splice(options.index, 0, this._map(item));\n      return this.length;\n    }\n    this._items.push(this._map(item));\n    return this._items.length;\n  }\n  _addOneOrMore(items, options) {\n    if (Array.isArray(items)) {\n      if (isDefined(options) && isDefined(options.index)) {\n        items = items.reverse();\n      }\n      for (const item of items) {\n        this._addOne(item, options);\n      }\n    } else {\n      this._addOne(items, options);\n    }\n    return this.length;\n  }\n  /**\n   * Get the collection as an array\n   */\n  toArray() {\n    return [...this._items];\n  }\n  reduce(callbackFn, initialValue) {\n    return this._items.reduce(callbackFn, initialValue);\n  }\n};\n\n// src/error.ts\nvar FleetError = class extends Error {\n  constructor(message, options) {\n    super(message, options);\n    Object.setPrototypeOf(this, new.target.prototype);\n    this.name = new.target.name;\n  }\n};\nvar NotSupportedError = class extends FleetError {\n  constructor(message) {\n    super(message);\n  }\n};\nvar BlockchainProviderError = class extends FleetError {\n  constructor(message, options) {\n    super(message, options);\n  }\n};\n\n\n//# sourceMappingURL=out.js.map\n//# sourceMappingURL=index.mjs.map\n\n//# sourceURL=webpack://my-project/./node_modules/@fleet-sdk/core/node_modules/@fleet-sdk/common/dist/index.mjs?");

/***/ }),

/***/ "./node_modules/@fleet-sdk/core/node_modules/@fleet-sdk/crypto/dist/index.mjs":
/*!************************************************************************************!*\
  !*** ./node_modules/@fleet-sdk/core/node_modules/@fleet-sdk/crypto/dist/index.mjs ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base58: () => (/* binding */ base58),\n/* harmony export */   base58check: () => (/* binding */ base58check),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   blake2b256: () => (/* binding */ blake2b256),\n/* harmony export */   hex: () => (/* binding */ hex),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   utf8: () => (/* binding */ utf8)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/utils */ \"./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/blake2b */ \"./node_modules/@noble/hashes/esm/blake2b.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @scure/base */ \"./node_modules/@scure/base/lib/esm/index.js\");\n/* harmony import */ var _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fleet-sdk/common */ \"./node_modules/@fleet-sdk/core/node_modules/@fleet-sdk/common/dist/index.mjs\");\n\n\n\n\n\n\n// src/index.ts\nvar HEXES = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, \"0\"));\nfunction bytesToHex(bytes) {\n  (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.assertInstanceOf)(bytes, Uint8Array);\n  let hex2 = \"\";\n  for (let i = 0, len = bytes.length; i < len; i++) {\n    hex2 += HEXES[bytes[i]];\n  }\n  return hex2;\n}\nfunction hexToBytes(hex2) {\n  (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.assertTypeOf)(hex2, \"string\");\n  (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.assert)(hex2.length % 2 === 0, \"Invalid hex padding.\");\n  const len = hex2.length / 2;\n  const bytes = new Uint8Array(len);\n  for (let i = 0, j = 0; i < len; i++) {\n    const n1 = charCodeToBase16(hex2.charCodeAt(j++));\n    const n2 = charCodeToBase16(hex2.charCodeAt(j++));\n    bytes[i] = n1 * 16 + n2;\n  }\n  return bytes;\n}\nfunction charCodeToBase16(char) {\n  if (char >= 48 /* ZERO */ && char <= 57 /* NINE */)\n    return char - 48 /* ZERO */;\n  if (char >= 65 /* A_UP */ && char <= 70 /* F_UP */)\n    return char - (65 /* A_UP */ - 10);\n  if (char >= 97 /* A_LO */ && char <= 102 /* F_LO */)\n    return char - (97 /* A_LO */ - 10);\n  throw new Error(\"Invalid byte sequence.\");\n}\nvar hex = {\n  encode: bytesToHex,\n  decode: hexToBytes\n};\nfunction bytesToUtf8(bytes) {\n  (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.assertInstanceOf)(bytes, Uint8Array);\n  return new TextDecoder().decode(bytes);\n}\nfunction utf8ToBytes(str) {\n  (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.assertTypeOf)(str, \"string\");\n  return new Uint8Array(new TextEncoder().encode(str));\n}\nvar utf8 = {\n  encode: bytesToUtf8,\n  decode: utf8ToBytes\n};\n\n// src/coders/index.ts\nvar base58check = (0,_scure_base__WEBPACK_IMPORTED_MODULE_1__.base58check)(sha256);\nvar base58 = _scure_base__WEBPACK_IMPORTED_MODULE_1__.base58;\nvar base64 = _scure_base__WEBPACK_IMPORTED_MODULE_1__.base64;\n\n// src/hashes.ts\nfunction ensureBytes(input) {\n  if (input instanceof Uint8Array)\n    return input;\n  return hex.decode(input);\n}\nfunction blake2b256(message) {\n  return (0,_noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_2__.blake2b)(ensureBytes(message), { dkLen: 32 });\n}\nfunction sha256(message) {\n  return (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_3__.sha256)(ensureBytes(message));\n}\n\n// src/index.ts\nvar randomBytes = _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.randomBytes;\n\n\n//# sourceMappingURL=out.js.map\n//# sourceMappingURL=index.mjs.map\n\n//# sourceURL=webpack://my-project/./node_modules/@fleet-sdk/core/node_modules/@fleet-sdk/crypto/dist/index.mjs?");

/***/ }),

/***/ "./node_modules/@fleet-sdk/core/node_modules/@fleet-sdk/serializer/dist/index.mjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/@fleet-sdk/core/node_modules/@fleet-sdk/serializer/dist/index.mjs ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataSerializer: () => (/* binding */ DataSerializer),\n/* harmony export */   SBigInt: () => (/* binding */ SBigInt),\n/* harmony export */   SBigIntType: () => (/* binding */ SBigIntType),\n/* harmony export */   SBool: () => (/* binding */ SBool),\n/* harmony export */   SBoolType: () => (/* binding */ SBoolType),\n/* harmony export */   SByte: () => (/* binding */ SByte),\n/* harmony export */   SByteType: () => (/* binding */ SByteType),\n/* harmony export */   SColl: () => (/* binding */ SColl),\n/* harmony export */   SCollType: () => (/* binding */ SCollType),\n/* harmony export */   SConstant: () => (/* binding */ SConstant),\n/* harmony export */   SGenericType: () => (/* binding */ SGenericType),\n/* harmony export */   SGroupElement: () => (/* binding */ SGroupElement),\n/* harmony export */   SGroupElementType: () => (/* binding */ SGroupElementType),\n/* harmony export */   SInt: () => (/* binding */ SInt),\n/* harmony export */   SIntType: () => (/* binding */ SIntType),\n/* harmony export */   SLong: () => (/* binding */ SLong),\n/* harmony export */   SLongType: () => (/* binding */ SLongType),\n/* harmony export */   SMonomorphicType: () => (/* binding */ SMonomorphicType),\n/* harmony export */   SPair: () => (/* binding */ SPair),\n/* harmony export */   SPrimitiveType: () => (/* binding */ SPrimitiveType),\n/* harmony export */   SShort: () => (/* binding */ SShort),\n/* harmony export */   SShortType: () => (/* binding */ SShortType),\n/* harmony export */   SSigmaProp: () => (/* binding */ SSigmaProp),\n/* harmony export */   SSigmaPropType: () => (/* binding */ SSigmaPropType),\n/* harmony export */   STupleType: () => (/* binding */ STupleType),\n/* harmony export */   SType: () => (/* binding */ SType),\n/* harmony export */   SUnit: () => (/* binding */ SUnit),\n/* harmony export */   SUnitType: () => (/* binding */ SUnitType),\n/* harmony export */   TypeSerializer: () => (/* binding */ TypeSerializer),\n/* harmony export */   estimateBoxSize: () => (/* binding */ estimateBoxSize),\n/* harmony export */   estimateVLQSize: () => (/* binding */ estimateVLQSize),\n/* harmony export */   isColl: () => (/* binding */ isColl),\n/* harmony export */   isTuple: () => (/* binding */ isTuple),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   serializeBox: () => (/* binding */ serializeBox),\n/* harmony export */   serializeTransaction: () => (/* binding */ serializeTransaction)\n/* harmony export */ });\n/* harmony import */ var _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fleet-sdk/common */ \"./node_modules/@fleet-sdk/core/node_modules/@fleet-sdk/common/dist/index.mjs\");\n/* harmony import */ var _fleet_sdk_crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fleet-sdk/crypto */ \"./node_modules/@fleet-sdk/core/node_modules/@fleet-sdk/crypto/dist/index.mjs\");\n\n\n\n// src/coders/sigmaReader.ts\nfunction hexToBigInt(hex6) {\n  if (hex6.length % 2) {\n    hex6 = \"0\" + hex6;\n  }\n  const value = BigInt(\"0x\" + hex6);\n  const highByte = parseInt(hex6.slice(0, 2), 16);\n  if (128 & highByte) {\n    return -_bitNegate(value);\n  }\n  return value;\n}\nfunction bigIntToHex(value) {\n  const positive = value >= _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._0n;\n  if (!positive) {\n    value = _bitNegate(value);\n  }\n  let hex6 = value.toString(16);\n  if (hex6.length % 2) {\n    hex6 = \"0\" + hex6;\n  }\n  if (positive && 128 & parseInt(hex6.slice(0, 2), 16)) {\n    hex6 = \"00\" + hex6;\n  }\n  return hex6;\n}\nfunction _bitNegate(value) {\n  const negative = value < _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._0n;\n  if (negative) {\n    value = -value;\n  }\n  const bits = value.toString(2);\n  let bitLen = bits.length;\n  const mod = bitLen % 8;\n  if (mod > 0) {\n    bitLen += 8 - mod;\n  } else if (negative && (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.first)(bits) === \"1\" && bits.indexOf(\"1\", 1) !== -1) {\n    bitLen += 8;\n  }\n  const mask = (1n << BigInt(bitLen)) - 1n;\n  return (~value & mask) + 1n;\n}\nfunction writeVLQ(writer, value) {\n  if (value === 0) {\n    return writer.write(0);\n  } else if (value < 0) {\n    throw new RangeError(\"Variable Length Quantity not supported for negative numbers.\");\n  }\n  do {\n    let lower7bits = value & 127;\n    value >>= 7;\n    if (value > 0) {\n      lower7bits |= 128;\n    }\n    writer.write(lower7bits);\n  } while (value > 0);\n  return writer;\n}\nfunction readVLQ(reader) {\n  if (reader.isEmpty) {\n    return 0;\n  }\n  let value = 0;\n  let shift = 0;\n  let lower7bits = 0;\n  do {\n    lower7bits = reader.readByte();\n    value |= (lower7bits & 127) << shift;\n    shift += 7;\n  } while ((lower7bits & 128) != 0);\n  return value;\n}\nfunction writeBigVLQ(writer, value) {\n  if (value === _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._0n) {\n    return writer.write(0);\n  } else if (value < _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._0n) {\n    throw new RangeError(\"Variable Length Quantity not supported for negative numbers\");\n  }\n  do {\n    let lower7bits = Number(value & _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._127n);\n    value >>= _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._7n;\n    if (value > 0) {\n      lower7bits |= 128;\n    }\n    writer.write(lower7bits);\n  } while (value > 0);\n  return writer;\n}\nfunction readBigVLQ(reader) {\n  if (reader.isEmpty) {\n    return _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._0n;\n  }\n  let value = _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._0n;\n  let shift = _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._0n;\n  let lower7bits = _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._0n;\n  do {\n    lower7bits = BigInt(reader.readByte());\n    value |= (lower7bits & _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._127n) << shift;\n    shift += _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._7n;\n  } while ((lower7bits & _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._128n) != _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._0n);\n  return value;\n}\nfunction estimateVLQSize(value) {\n  let size = 0;\n  if (typeof value === \"number\") {\n    do {\n      size++;\n      value = Math.floor(value / 128);\n    } while (value > 0);\n    return size;\n  }\n  value = (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.ensureBigInt)(value);\n  do {\n    size++;\n    value /= _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._128n;\n  } while (value > _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._0n);\n  return size;\n}\nfunction zigZagEncode(input) {\n  return input << 1 ^ input >> 63;\n}\nfunction zigZagDecode(input) {\n  return input >> 1 ^ -(input & 1);\n}\nfunction zigZagEncodeBigInt(input) {\n  return input << _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._1n ^ input >> _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._63n;\n}\nfunction zigZagDecodeBigInt(input) {\n  return input >> _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._1n ^ -(input & _fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__._1n);\n}\n\n// src/coders/sigmaReader.ts\nvar SigmaReader = class {\n  #bytes;\n  #cursor;\n  get isEmpty() {\n    return (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(this.#bytes);\n  }\n  constructor(bytes) {\n    if (typeof bytes === \"string\") {\n      this.#bytes = _fleet_sdk_crypto__WEBPACK_IMPORTED_MODULE_1__.hex.decode(bytes);\n    } else {\n      this.#bytes = bytes;\n    }\n    this.#cursor = 0;\n  }\n  readBoolean() {\n    return this.readByte() === 1;\n  }\n  readBits(length) {\n    const bits = new Array(length);\n    let bitOffset = 0;\n    for (let i = 0; i < length; i++) {\n      const bit = this.#bytes[this.#cursor] >> bitOffset++ & 1;\n      bits[i] = bit === 1;\n      if (bitOffset == 8) {\n        bitOffset = 0;\n        this.#cursor++;\n      }\n    }\n    if (bitOffset > 0) {\n      this.#cursor++;\n    }\n    return bits;\n  }\n  readByte() {\n    return this.#bytes[this.#cursor++];\n  }\n  readBytes(length) {\n    return this.#bytes.subarray(this.#cursor, this.#cursor += length);\n  }\n  readVlq() {\n    return readVLQ(this);\n  }\n  readShort() {\n    return Number(zigZagDecode(readVLQ(this)));\n  }\n  readInt() {\n    const int = this.readLong();\n    return Number(int);\n  }\n  readLong() {\n    return zigZagDecodeBigInt(readBigVLQ(this));\n  }\n  readBigInt() {\n    const len = readVLQ(this);\n    return hexToBigInt(_fleet_sdk_crypto__WEBPACK_IMPORTED_MODULE_1__.hex.encode(this.readBytes(len)));\n  }\n};\nvar SigmaWriter = class {\n  #bytes;\n  #cursor;\n  get length() {\n    return this.#cursor;\n  }\n  constructor(maxLength) {\n    this.#bytes = new Uint8Array(maxLength);\n    this.#cursor = 0;\n  }\n  writeBoolean(value) {\n    this.write(value === true ? 1 : 0);\n    return this;\n  }\n  writeVLQ(value) {\n    return writeVLQ(this, value);\n  }\n  writeBigVLQ(value) {\n    return writeBigVLQ(this, value);\n  }\n  writeShort(value) {\n    this.writeVLQ(zigZagEncode(value));\n    return this;\n  }\n  writeInt(value) {\n    this.writeLong(BigInt(value));\n    return this;\n  }\n  writeLong(value) {\n    this.writeBigVLQ(zigZagEncodeBigInt(value));\n    return this;\n  }\n  write(byte) {\n    this.#bytes[this.#cursor++] = byte;\n    return this;\n  }\n  writeBytes(bytes) {\n    this.#bytes.set(bytes, this.#cursor);\n    this.#cursor += bytes.length;\n    return this;\n  }\n  writeHex(bytesHex) {\n    return this.writeBytes(_fleet_sdk_crypto__WEBPACK_IMPORTED_MODULE_1__.hex.decode(bytesHex));\n  }\n  writeBits(bits) {\n    let bitOffset = 0;\n    for (let i = 0; i < bits.length; i++) {\n      if (bits[i]) {\n        this.#bytes[this.#cursor] |= 1 << bitOffset++;\n      } else {\n        this.#bytes[this.#cursor] &= ~(1 << bitOffset++);\n      }\n      if (bitOffset == 8) {\n        bitOffset = 0;\n        this.#cursor++;\n      }\n    }\n    if (bitOffset > 0) {\n      this.#cursor++;\n    }\n    return this;\n  }\n  writeBigInt(value) {\n    const hex6 = bigIntToHex(value);\n    this.writeVLQ(hex6.length / 2);\n    this.writeHex(hex6);\n    return this;\n  }\n  toHex() {\n    return _fleet_sdk_crypto__WEBPACK_IMPORTED_MODULE_1__.hex.encode(this.toBytes());\n  }\n  toBytes() {\n    return this.#bytes.subarray(0, this.#cursor);\n  }\n};\n\n// src/types/base.ts\nvar SType = class {\n  coerce(data) {\n    return data;\n  }\n};\nvar SMonomorphicType = class extends SType {\n  get embeddable() {\n    return false;\n  }\n};\nvar SPrimitiveType = class extends SMonomorphicType {\n  get embeddable() {\n    return true;\n  }\n};\nvar SGenericType = class extends SType {\n  #internalType;\n  constructor(type) {\n    super();\n    this.#internalType = type;\n  }\n  get elementsType() {\n    return this.#internalType;\n  }\n  get embeddable() {\n    return false;\n  }\n};\nvar SBoolType = class extends SPrimitiveType {\n  get code() {\n    return 1;\n  }\n  toString() {\n    return \"SBool\";\n  }\n};\nvar SByteType = class extends SPrimitiveType {\n  get code() {\n    return 2;\n  }\n  toString() {\n    return \"SByte\";\n  }\n};\nvar SShortType = class extends SPrimitiveType {\n  get code() {\n    return 3;\n  }\n  toString() {\n    return \"SShort\";\n  }\n};\nvar SIntType = class extends SPrimitiveType {\n  get code() {\n    return 4;\n  }\n  toString() {\n    return \"SInt\";\n  }\n};\nvar SLongType = class extends SPrimitiveType {\n  get code() {\n    return 5;\n  }\n  coerce(data) {\n    return (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.ensureBigInt)(data);\n  }\n  toString() {\n    return \"SLong\";\n  }\n};\nvar SBigIntType = class extends SPrimitiveType {\n  get code() {\n    return 6;\n  }\n  coerce(data) {\n    return (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.ensureBigInt)(data);\n  }\n  toString() {\n    return \"SBigInt\";\n  }\n};\nvar SGroupElementType = class extends SPrimitiveType {\n  get code() {\n    return 7;\n  }\n  coerce(data) {\n    return typeof data === \"string\" ? _fleet_sdk_crypto__WEBPACK_IMPORTED_MODULE_1__.hex.decode(data) : data;\n  }\n  toString() {\n    return \"SGroupElement\";\n  }\n};\nvar SSigmaPropType = class extends SPrimitiveType {\n  get code() {\n    return 8;\n  }\n  toString() {\n    return \"SSigmaProp\";\n  }\n};\n\n// src/types/monomorphics.ts\nvar SUnitType = class extends SMonomorphicType {\n  get code() {\n    return 98;\n  }\n  toString() {\n    return \"SUnit\";\n  }\n};\n\n// src/types/descriptors.ts\nvar constructorCode = Object.freeze({\n  embeddable: 0,\n  simpleColl: 1,\n  nestedColl: 2,\n  option: 3,\n  optionCollection: 4,\n  pairOne: 5,\n  pairTwo: 6,\n  symmetricPair: 7,\n  genericTuple: 8\n});\nvar MAX_PRIMITIVE_TYPE_CODE = 11;\nvar PRIMITIVE_TYPE_RANGE = MAX_PRIMITIVE_TYPE_CODE + 1;\nvar typeCodeOf = (constructor) => PRIMITIVE_TYPE_RANGE * constructor;\nvar collDescriptor = Object.freeze({\n  code: typeCodeOf(constructorCode.simpleColl),\n  embeddable: false,\n  simpleCollTypeCode: typeCodeOf(constructorCode.simpleColl),\n  nestedCollTypeCode: typeCodeOf(constructorCode.nestedColl)\n});\nvar tupleDescriptor = Object.freeze({\n  code: typeCodeOf(constructorCode.pairOne),\n  embeddable: false,\n  pairOneTypeCode: typeCodeOf(constructorCode.pairOne),\n  pairTwoTypeCode: typeCodeOf(constructorCode.pairTwo),\n  tripleTypeCode: typeCodeOf(constructorCode.pairTwo),\n  symmetricPairTypeCode: typeCodeOf(constructorCode.symmetricPair),\n  quadrupleTypeCode: typeCodeOf(constructorCode.symmetricPair),\n  genericTupleTypeCode: typeCodeOf(constructorCode.genericTuple)\n});\nvar descriptors = {\n  bool: new SBoolType(),\n  byte: new SByteType(),\n  short: new SShortType(),\n  int: new SIntType(),\n  long: new SLongType(),\n  bigInt: new SBigIntType(),\n  groupElement: new SGroupElementType(),\n  sigmaProp: new SSigmaPropType(),\n  unit: new SUnitType(),\n  coll: collDescriptor,\n  tuple: tupleDescriptor\n};\nfunction isColl(type) {\n  return type.code >= descriptors.coll.simpleCollTypeCode && type.code <= descriptors.coll.nestedCollTypeCode + MAX_PRIMITIVE_TYPE_CODE;\n}\nfunction isTuple(type) {\n  return type.code >= descriptors.tuple.pairOneTypeCode && type.code <= descriptors.tuple.genericTupleTypeCode;\n}\nfunction getPrimitiveType(typeCode) {\n  switch (typeCode) {\n    case descriptors.bool.code:\n      return descriptors.bool;\n    case descriptors.byte.code:\n      return descriptors.byte;\n    case descriptors.short.code:\n      return descriptors.short;\n    case descriptors.int.code:\n      return descriptors.int;\n    case descriptors.long.code:\n      return descriptors.long;\n    case descriptors.bigInt.code:\n      return descriptors.bigInt;\n    case descriptors.groupElement.code:\n      return descriptors.groupElement;\n    case descriptors.sigmaProp.code:\n      return descriptors.sigmaProp;\n    default:\n      throw new Error(\n        `The type code '0x${typeCode.toString(16)}' is not a valid primitive type code.`\n      );\n  }\n}\nvar SCollType = class extends SGenericType {\n  get code() {\n    return descriptors.coll.code;\n  }\n  coerce(elements) {\n    if (this.elementsType.code === descriptors.byte.code && !(elements instanceof Uint8Array)) {\n      return typeof elements === \"string\" ? _fleet_sdk_crypto__WEBPACK_IMPORTED_MODULE_1__.hex.decode(elements) : Uint8Array.from(elements);\n    }\n    return elements.map((el) => this.elementsType.coerce(el));\n  }\n  toString() {\n    return `SColl[${this.elementsType.toString()}]`;\n  }\n};\nvar STupleType = class extends SGenericType {\n  get code() {\n    return descriptors.tuple.code;\n  }\n  coerce(elements) {\n    const output = new Array(elements.length);\n    for (let i = 0; i < elements.length; i++) {\n      output[i] = this.elementsType[i].coerce(elements[i]);\n    }\n    return output;\n  }\n  toString() {\n    return `(${this.elementsType.map((el) => el.toString()).join(\", \")})`;\n  }\n};\nfunction monoProxy(ctor, cache, forceConstruction) {\n  return new Proxy(ctor, {\n    apply: (target, _, args) => {\n      const instance = cache ?? new target();\n      if (!forceConstruction && (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(args))\n        return instance;\n      return new SConstant(instance, ...args);\n    }\n  });\n}\nfunction genericProxy(ctor, handler) {\n  return new Proxy(ctor, {\n    apply: handler\n  });\n}\nvar SByte = monoProxy(SByteType, descriptors.byte);\nvar SBool = monoProxy(SBoolType, descriptors.bool);\nvar SShort = monoProxy(SShortType, descriptors.short);\nvar SInt = monoProxy(SIntType, descriptors.int);\nvar SLong = monoProxy(SLongType, descriptors.long);\nvar SBigInt = monoProxy(SBigIntType, descriptors.bigInt);\nvar SGroupElement = monoProxy(\n  SGroupElementType,\n  descriptors.groupElement\n);\nvar SSigmaProp = monoProxy(\n  SSigmaPropType,\n  descriptors.sigmaProp\n);\nvar SUnit = monoProxy(SUnitType, void 0, true);\nvar SColl = genericProxy(SCollType, (target, _, args) => {\n  const [type, elements] = args;\n  const elementsType = type();\n  if (!elements)\n    return () => new target(elementsType);\n  return new SConstant(new target(elementsType), elements);\n});\nvar SPair = genericProxy(STupleType, (target, _, args) => {\n  const [left, right] = args;\n  if (typeof left === \"function\" && typeof right === \"function\") {\n    return () => new target([left(), right()]);\n  } else if (left instanceof SConstant && right instanceof SConstant) {\n    return new SConstant(new target([left.type, right.type]), [left.data, right.data]);\n  }\n  throw new Error(\"Invalid tuple declaration.\");\n});\n\n// src/serializers/dataSerializer.ts\nvar GROUP_ELEMENT_LENGTH = 33;\nvar PROVE_DLOG_OP = 205;\nvar DataSerializer = class _DataSerializer {\n  static serialize(data, type, writer) {\n    if (type.embeddable) {\n      switch (type.code) {\n        case descriptors.bool.code:\n          return writer.writeBoolean(data);\n        case descriptors.byte.code:\n          return writer.write(data);\n        case descriptors.short.code:\n          return writer.writeShort(data);\n        case descriptors.int.code:\n          return writer.writeInt(data);\n        case descriptors.long.code:\n          return writer.writeLong(data);\n        case descriptors.bigInt.code: {\n          return writer.writeBigInt(data);\n        }\n        case descriptors.groupElement.code:\n          return writer.writeBytes(data);\n        case descriptors.sigmaProp.code: {\n          const node = data;\n          if (node.type === descriptors.groupElement) {\n            writer.write(PROVE_DLOG_OP);\n            return _DataSerializer.serialize(node.data, node.type, writer);\n          } else {\n            throw Error(\"Serialization error: SigmaProp operation not implemented.\");\n          }\n        }\n      }\n    } else if (isColl(type)) {\n      if (type.elementsType.code === descriptors.byte.code) {\n        const isUint8Array = data instanceof Uint8Array;\n        (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.assert)(isUint8Array, `SColl[Byte] expected an UInt8Array, got ${typeof data}.`);\n      } else {\n        (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.assert)(Array.isArray(data), `SColl expected an array, got ${typeof data}.`);\n      }\n      writer.writeVLQ(data.length);\n      switch (type.elementsType.code) {\n        case descriptors.bool.code: {\n          return writer.writeBits(data);\n        }\n        case descriptors.byte.code: {\n          return writer.writeBytes(data);\n        }\n        default: {\n          for (let i = 0; i < data.length; i++) {\n            _DataSerializer.serialize(data[i], type.elementsType, writer);\n          }\n          return writer;\n        }\n      }\n    } else if (isTuple(type)) {\n      (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.assert)(\n        Array.isArray(data),\n        `STupleType serialization expected an array, got ${typeof data}.`\n      );\n      const len = type.elementsType.length;\n      for (let i = 0; i < len; i++) {\n        _DataSerializer.serialize(data[i], type.elementsType[i], writer);\n      }\n      return writer;\n    } else if (type.code === descriptors.unit.code) {\n      return writer;\n    }\n    throw Error(`Serialization error: '0x${type.code.toString(16)}' type not implemented.`);\n  }\n  static deserialize(type, reader) {\n    if (type.embeddable) {\n      switch (type.code) {\n        case descriptors.bool.code:\n          return reader.readBoolean();\n        case descriptors.byte.code:\n          return reader.readByte();\n        case descriptors.short.code:\n          return reader.readShort();\n        case descriptors.int.code:\n          return reader.readInt();\n        case descriptors.long.code:\n          return reader.readLong();\n        case descriptors.bigInt.code:\n          return reader.readBigInt();\n        case descriptors.groupElement.code:\n          return reader.readBytes(GROUP_ELEMENT_LENGTH);\n        case descriptors.sigmaProp.code: {\n          if (reader.readByte() === PROVE_DLOG_OP) {\n            return this.deserialize(descriptors.groupElement, reader);\n          }\n          break;\n        }\n      }\n    } else {\n      switch (type.code) {\n        case descriptors.coll.code: {\n          const length = reader.readVlq();\n          const embeddedType = type.elementsType;\n          switch (embeddedType.code) {\n            case descriptors.bool.code:\n              return reader.readBits(length);\n            case descriptors.byte.code:\n              return reader.readBytes(length);\n            default: {\n              const elements = new Array(length);\n              for (let i = 0; i < length; i++) {\n                elements[i] = this.deserialize(embeddedType, reader);\n              }\n              return elements;\n            }\n          }\n        }\n        case descriptors.tuple.code: {\n          return type.elementsType.map((t) => this.deserialize(t, reader));\n        }\n        case descriptors.unit.code: {\n          return void 0;\n        }\n      }\n    }\n    throw new Error(`Parsing error: '0x${type.code.toString(16)}' type not implemented.`);\n  }\n};\nvar TypeSerializer = class {\n  static serialize(type, writer) {\n    if (type.embeddable) {\n      writer.write(type.code);\n    } else if (type.code === descriptors.unit.code) {\n      writer.write(type.code);\n    } else if (isColl(type)) {\n      if (type.elementsType.embeddable) {\n        writer.write(descriptors.coll.simpleCollTypeCode + type.elementsType.code);\n      } else if (isColl(type.elementsType)) {\n        const nestedColl = type.elementsType;\n        if (nestedColl.elementsType.embeddable) {\n          writer.write(descriptors.coll.nestedCollTypeCode + nestedColl.elementsType.code);\n        } else {\n          writer.write(descriptors.coll.simpleCollTypeCode);\n          this.serialize(nestedColl, writer);\n        }\n      } else {\n        writer.write(descriptors.coll.simpleCollTypeCode);\n        this.serialize(type.elementsType, writer);\n      }\n    } else if (isTuple(type)) {\n      switch (type.elementsType.length) {\n        case 2: {\n          const left = (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.first)(type.elementsType);\n          const right = (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.last)(type.elementsType);\n          if (left.embeddable) {\n            if (left.code === right.code) {\n              writer.write(descriptors.tuple.symmetricPairTypeCode + left.code);\n            } else {\n              writer.write(descriptors.tuple.pairOneTypeCode + left.code);\n              this.serialize(right, writer);\n            }\n          } else if (right.embeddable) {\n            writer.write(descriptors.tuple.pairTwoTypeCode + right.code);\n            this.serialize(left, writer);\n          } else {\n            writer.write(descriptors.tuple.pairOneTypeCode);\n            this.serialize(left, writer);\n            this.serialize(right, writer);\n          }\n          return;\n        }\n        case 3:\n          writer.write(descriptors.tuple.tripleTypeCode);\n          break;\n        case 4:\n          writer.write(descriptors.tuple.quadrupleTypeCode);\n          break;\n        default: {\n          const len = type.elementsType.length;\n          (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.assert)(len >= 2 && len <= 255, \"Invalid type: tuples must have between 2 and 255 items.\");\n          writer.write(descriptors.tuple.genericTupleTypeCode);\n          writer.writeVLQ(len);\n        }\n      }\n      for (let i = 0; i < type.elementsType.length; i++) {\n        this.serialize(type.elementsType[i], writer);\n      }\n    } else {\n      throw new Error(\"Serialization error: type not implemented.\");\n    }\n  }\n  static deserialize(r) {\n    const byte = r.readByte();\n    (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.assert)(byte > 0, `Parsing Error: Unexpected type code '0x${byte.toString(16)}'`);\n    if (byte < descriptors.tuple.genericTupleTypeCode) {\n      const ctorCode = Math.floor(byte / PRIMITIVE_TYPE_RANGE);\n      const embdCode = Math.floor(byte % PRIMITIVE_TYPE_RANGE);\n      switch (ctorCode) {\n        case constructorCode.embeddable: {\n          return getPrimitiveType(embdCode);\n        }\n        case constructorCode.simpleColl: {\n          const internal = embdCode === 0 ? this.deserialize(r) : getPrimitiveType(embdCode);\n          return new SCollType(internal);\n        }\n        case constructorCode.nestedColl: {\n          return new SCollType(new SCollType(getPrimitiveType(embdCode)));\n        }\n        case constructorCode.pairOne: {\n          const internal = embdCode === 0 ? [this.deserialize(r), this.deserialize(r)] : [getPrimitiveType(embdCode), this.deserialize(r)];\n          return new STupleType(internal);\n        }\n        case constructorCode.pairTwo: {\n          const internal = embdCode === 0 ? [this.deserialize(r), this.deserialize(r), this.deserialize(r)] : [this.deserialize(r), getPrimitiveType(embdCode)];\n          return new STupleType(internal);\n        }\n        case constructorCode.symmetricPair: {\n          const internal = embdCode === 0 ? [this.deserialize(r), this.deserialize(r), this.deserialize(r), this.deserialize(r)] : [getPrimitiveType(embdCode), getPrimitiveType(embdCode)];\n          return new STupleType(internal);\n        }\n      }\n    } else {\n      switch (byte) {\n        case descriptors.tuple.genericTupleTypeCode: {\n          const len = r.readVlq();\n          const wrapped = new Array(len);\n          for (let i = 0; i < len; i++) {\n            wrapped[i] = this.deserialize(r);\n          }\n          return new STupleType(wrapped);\n        }\n        case descriptors.unit.code: {\n          return descriptors.unit;\n        }\n      }\n    }\n    throw new Error(\"Not implemented.\");\n  }\n};\n\n// src/sigmaConstant.ts\nvar MAX_CONSTANT_LENGTH = 4096;\nvar SConstant = class _SConstant {\n  #type;\n  #data;\n  constructor(type, data) {\n    this.#type = type;\n    this.#data = type.coerce(data);\n  }\n  static from(bytes) {\n    (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.assert)(bytes.length > 0, \"Empty constant bytes.\");\n    const reader = new SigmaReader(bytes);\n    const type = TypeSerializer.deserialize(reader);\n    const data = DataSerializer.deserialize(type, reader);\n    return new _SConstant(type, data);\n  }\n  get type() {\n    return this.#type;\n  }\n  get data() {\n    return this.#data;\n  }\n  toBytes() {\n    const writer = new SigmaWriter(MAX_CONSTANT_LENGTH);\n    TypeSerializer.serialize(this.type, writer);\n    DataSerializer.serialize(this.data, this.type, writer);\n    return writer.toBytes();\n  }\n  toHex() {\n    return _fleet_sdk_crypto__WEBPACK_IMPORTED_MODULE_1__.hex.encode(this.toBytes());\n  }\n};\nfunction parse(constant, mode = \"strict\") {\n  if (mode === \"strict\")\n    return SConstant.from(constant ?? \"\").data;\n  if (!constant)\n    return;\n  try {\n    return SConstant.from(constant).data;\n  } catch {\n    return;\n  }\n}\nvar MAX_UINT16_VALUE = 65535;\nfunction serializeBox(box, writer, distinctTokenIds) {\n  if (!writer) {\n    writer = new SigmaWriter(5e4);\n  }\n  writer.writeBigVLQ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.ensureBigInt)(box.value));\n  writer.writeHex(box.ergoTree);\n  writer.writeVLQ(box.creationHeight);\n  writeTokens(writer, box.assets, distinctTokenIds);\n  writeRegisters(writer, box.additionalRegisters);\n  if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isDefined)(distinctTokenIds)) {\n    return writer;\n  } else {\n    if (!isBox(box)) {\n      throw new Error(\"Invalid box type.\");\n    }\n    return writer.writeHex(box.transactionId).writeVLQ(box.index);\n  }\n}\nfunction isBox(box) {\n  const castedBox = box;\n  return (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isDefined)(castedBox.transactionId) && (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isDefined)(castedBox.index);\n}\nfunction writeTokens(writer, tokens, tokenIds) {\n  if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(tokens)) {\n    writer.write(0);\n    return;\n  }\n  writer.writeVLQ(tokens.length);\n  if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.some)(tokenIds)) {\n    tokens.map(\n      (token) => writer.writeVLQ(tokenIds.indexOf(token.tokenId)).writeBigVLQ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.ensureBigInt)(token.amount))\n    );\n  } else {\n    tokens.map((token) => writer.writeHex(token.tokenId).writeBigVLQ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.ensureBigInt)(token.amount)));\n  }\n}\nfunction writeRegisters(writer, registers) {\n  const keys = Object.keys(registers).sort();\n  let length = 0;\n  for (const key of keys) {\n    if (registers[key]) {\n      length++;\n    }\n  }\n  writer.writeVLQ(length);\n  if (length == 0) {\n    return;\n  }\n  for (const key of keys) {\n    const register = registers[key];\n    if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isDefined)(register)) {\n      writer.writeHex(register);\n    }\n  }\n}\nfunction estimateBoxSize(box, withValue) {\n  if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(box.creationHeight)) {\n    throw new Error(\"Box size estimation error: creation height is undefined.\");\n  }\n  let size = 0;\n  size += estimateVLQSize((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isDefined)(withValue) ? withValue : box.value);\n  size += (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.byteSizeOf)(box.ergoTree);\n  size += estimateVLQSize(box.creationHeight);\n  size += estimateVLQSize(box.assets.length);\n  size += box.assets.reduce(\n    (acc, curr) => acc += (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.byteSizeOf)(curr.tokenId) + estimateVLQSize(curr.amount),\n    0\n  );\n  let registersLength = 0;\n  for (const key in box.additionalRegisters) {\n    const register = box.additionalRegisters[key];\n    if (register) {\n      size += (0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.byteSizeOf)(register);\n      registersLength++;\n    }\n  }\n  size += estimateVLQSize(registersLength);\n  size += 32;\n  size += estimateVLQSize(isBox(box) ? box.index : MAX_UINT16_VALUE);\n  return size;\n}\nfunction serializeTransaction(transaction) {\n  const writer = new SigmaWriter(1e5);\n  writer.writeVLQ(transaction.inputs.length);\n  transaction.inputs.map((input) => writeInput(writer, input));\n  writer.writeVLQ(transaction.dataInputs.length);\n  transaction.dataInputs.map((dataInput) => writer.writeHex(dataInput.boxId));\n  const distinctTokenIds = getDistinctTokenIds(transaction.outputs);\n  writer.writeVLQ(distinctTokenIds.length);\n  distinctTokenIds.map((tokenId) => writer.writeHex(tokenId));\n  writer.writeVLQ(transaction.outputs.length);\n  transaction.outputs.map((output) => serializeBox(output, writer, distinctTokenIds));\n  return writer;\n}\nfunction writeInput(writer, input) {\n  writer.writeHex(input.boxId);\n  writer.write(0);\n  writeExtension(writer, input.extension);\n}\nfunction writeExtension(writer, extension) {\n  const keys = Object.keys(extension);\n  let length = 0;\n  for (const key of keys) {\n    const ext = extension[key];\n    if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isDefined)(ext)) {\n      length++;\n    }\n  }\n  writer.writeVLQ(length);\n  if (length == 0) {\n    return;\n  }\n  for (const key of keys) {\n    const ext = extension[key];\n    if ((0,_fleet_sdk_common__WEBPACK_IMPORTED_MODULE_0__.isDefined)(ext)) {\n      writer.writeVLQ(Number(key)).writeHex(ext);\n    }\n  }\n}\nfunction getDistinctTokenIds(outputs) {\n  const tokenIds = /* @__PURE__ */ new Set();\n  outputs.flatMap((output) => output.assets.map((asset) => tokenIds.add(asset.tokenId)));\n  return Array.from(tokenIds);\n}\n\n\n//# sourceMappingURL=out.js.map\n//# sourceMappingURL=index.mjs.map\n\n//# sourceURL=webpack://my-project/./node_modules/@fleet-sdk/core/node_modules/@fleet-sdk/serializer/dist/index.mjs?");

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/_assert.js":
/*!***************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_assert.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`positive integer expected, not ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\n// copied from utils\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(h.outputLen);\n    number(h.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = { number, bool, bytes, hash, exists, output };\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);\n//# sourceMappingURL=_assert.js.map\n\n//# sourceURL=webpack://my-project/./node_modules/@noble/hashes/esm/_assert.js?");

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/_blake.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_blake.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BLAKE: () => (/* binding */ BLAKE),\n/* harmony export */   SIGMA: () => (/* binding */ SIGMA)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Blake is based on ChaCha permutation.\n// For BLAKE2b, the two extra permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].\n// prettier-ignore\nconst SIGMA = /* @__PURE__ */ new Uint8Array([\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n    14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n    11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n    7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n    9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n    2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n    12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,\n    13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,\n    6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,\n    10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n    14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n]);\nclass BLAKE extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, opts = {}, keyLen, saltLen, persLen) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.length = 0;\n        this.pos = 0;\n        this.finished = false;\n        this.destroyed = false;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.number)(blockLen);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.number)(outputLen);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.number)(keyLen);\n        if (outputLen < 0 || outputLen > keyLen)\n            throw new Error('outputLen bigger than keyLen');\n        if (opts.key !== undefined && (opts.key.length < 1 || opts.key.length > keyLen))\n            throw new Error(`key must be up 1..${keyLen} byte long or undefined`);\n        if (opts.salt !== undefined && opts.salt.length !== saltLen)\n            throw new Error(`salt must be ${saltLen} byte long or undefined`);\n        if (opts.personalization !== undefined && opts.personalization.length !== persLen)\n            throw new Error(`personalization must be ${persLen} byte long or undefined`);\n        this.buffer32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)((this.buffer = new Uint8Array(blockLen)));\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        // Main difference with other hashes: there is flag for last block,\n        // so we cannot process current block before we know that there\n        // is the next one. This significantly complicates logic and reduces ability\n        // to do zero-copy processing\n        const { blockLen, buffer, buffer32 } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        const offset = data.byteOffset;\n        const buf = data.buffer;\n        for (let pos = 0; pos < len;) {\n            // If buffer is full and we still have input (don't process last block, same as blake2s)\n            if (this.pos === blockLen) {\n                if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__.isLE)\n                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.byteSwap32)(buffer32);\n                this.compress(buffer32, 0, false);\n                if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__.isLE)\n                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.byteSwap32)(buffer32);\n                this.pos = 0;\n            }\n            const take = Math.min(blockLen - this.pos, len - pos);\n            const dataOffset = offset + pos;\n            // full block && aligned to 4 bytes && not last in input\n            if (take === blockLen && !(dataOffset % 4) && pos + take < len) {\n                const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));\n                if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__.isLE)\n                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.byteSwap32)(data32);\n                for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {\n                    this.length += blockLen;\n                    this.compress(data32, pos32, false);\n                }\n                if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__.isLE)\n                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.byteSwap32)(data32);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            this.length += take;\n            pos += take;\n        }\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        const { pos, buffer32 } = this;\n        this.finished = true;\n        // Padding\n        this.buffer.subarray(pos).fill(0);\n        if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__.isLE)\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.byteSwap32)(buffer32);\n        this.compress(buffer32, 0, true);\n        if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__.isLE)\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.byteSwap32)(buffer32);\n        const out32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(out);\n        this.get().forEach((v, i) => (out32[i] = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.byteSwapIfBE)(v)));\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        const { buffer, length, finished, destroyed, outputLen, pos } = this;\n        to || (to = new this.constructor({ dkLen: outputLen }));\n        to.set(...this.get());\n        to.length = length;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.outputLen = outputLen;\n        to.buffer.set(buffer);\n        to.pos = pos;\n        return to;\n    }\n}\n//# sourceMappingURL=_blake.js.map\n\n//# sourceURL=webpack://my-project/./node_modules/@noble/hashes/esm/_blake.js?");

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/_md.js":
/*!***********************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_md.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chi: () => (/* binding */ Chi),\n/* harmony export */   HashMD: () => (/* binding */ HashMD),\n/* harmony export */   Maj: () => (/* binding */ Maj)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nclass HashMD extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_md.js.map\n\n//# sourceURL=webpack://my-project/./node_modules/@noble/hashes/esm/_md.js?");

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/_u64.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_u64.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   add3H: () => (/* binding */ add3H),\n/* harmony export */   add3L: () => (/* binding */ add3L),\n/* harmony export */   add4H: () => (/* binding */ add4H),\n/* harmony export */   add4L: () => (/* binding */ add4L),\n/* harmony export */   add5H: () => (/* binding */ add5H),\n/* harmony export */   add5L: () => (/* binding */ add5L),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromBig: () => (/* binding */ fromBig),\n/* harmony export */   rotlBH: () => (/* binding */ rotlBH),\n/* harmony export */   rotlBL: () => (/* binding */ rotlBL),\n/* harmony export */   rotlSH: () => (/* binding */ rotlSH),\n/* harmony export */   rotlSL: () => (/* binding */ rotlSL),\n/* harmony export */   rotr32H: () => (/* binding */ rotr32H),\n/* harmony export */   rotr32L: () => (/* binding */ rotr32L),\n/* harmony export */   rotrBH: () => (/* binding */ rotrBH),\n/* harmony export */   rotrBL: () => (/* binding */ rotrBL),\n/* harmony export */   rotrSH: () => (/* binding */ rotrSH),\n/* harmony export */   rotrSL: () => (/* binding */ rotrSL),\n/* harmony export */   shrSH: () => (/* binding */ shrSH),\n/* harmony export */   shrSL: () => (/* binding */ shrSL),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   toBig: () => (/* binding */ toBig)\n/* harmony export */ });\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64);\n//# sourceMappingURL=_u64.js.map\n\n//# sourceURL=webpack://my-project/./node_modules/@noble/hashes/esm/_u64.js?");

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/blake2b.js":
/*!***************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/blake2b.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   blake2b: () => (/* binding */ blake2b)\n/* harmony export */ });\n/* harmony import */ var _blake_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_blake.js */ \"./node_modules/@noble/hashes/esm/_blake.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"./node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// Same as SHA-512 but LE\n// prettier-ignore\nconst B2B_IV = /* @__PURE__ */ new Uint32Array([\n    0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372, 0x5f1d36f1, 0xa54ff53a,\n    0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c, 0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19\n]);\n// Temporary buffer\nconst BBUF = /* @__PURE__ */ new Uint32Array(32);\n// Mixing function G splitted in two halfs\nfunction G1b(a, b, c, d, msg, x) {\n    // NOTE: V is LE here\n    const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\n    let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore\n    let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore\n    let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore\n    let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore\n    // v[a] = (v[a] + v[b] + x) | 0;\n    let ll = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3L(Al, Bl, Xl);\n    Ah = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3H(ll, Ah, Bh, Xh);\n    Al = ll | 0;\n    // v[d] = rotr(v[d] ^ v[a], 32)\n    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n    ({ Dh, Dl } = { Dh: _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotr32H(Dh, Dl), Dl: _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotr32L(Dh, Dl) });\n    // v[c] = (v[c] + v[d]) | 0;\n    ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(Ch, Cl, Dh, Dl));\n    // v[b] = rotr(v[b] ^ v[c], 24)\n    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n    ({ Bh, Bl } = { Bh: _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Bh, Bl, 24), Bl: _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Bh, Bl, 24) });\n    (BBUF[2 * a] = Al), (BBUF[2 * a + 1] = Ah);\n    (BBUF[2 * b] = Bl), (BBUF[2 * b + 1] = Bh);\n    (BBUF[2 * c] = Cl), (BBUF[2 * c + 1] = Ch);\n    (BBUF[2 * d] = Dl), (BBUF[2 * d + 1] = Dh);\n}\nfunction G2b(a, b, c, d, msg, x) {\n    // NOTE: V is LE here\n    const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\n    let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore\n    let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore\n    let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore\n    let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore\n    // v[a] = (v[a] + v[b] + x) | 0;\n    let ll = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3L(Al, Bl, Xl);\n    Ah = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3H(ll, Ah, Bh, Xh);\n    Al = ll | 0;\n    // v[d] = rotr(v[d] ^ v[a], 16)\n    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n    ({ Dh, Dl } = { Dh: _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Dh, Dl, 16), Dl: _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Dh, Dl, 16) });\n    // v[c] = (v[c] + v[d]) | 0;\n    ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(Ch, Cl, Dh, Dl));\n    // v[b] = rotr(v[b] ^ v[c], 63)\n    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n    ({ Bh, Bl } = { Bh: _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Bh, Bl, 63), Bl: _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Bh, Bl, 63) });\n    (BBUF[2 * a] = Al), (BBUF[2 * a + 1] = Ah);\n    (BBUF[2 * b] = Bl), (BBUF[2 * b + 1] = Bh);\n    (BBUF[2 * c] = Cl), (BBUF[2 * c + 1] = Ch);\n    (BBUF[2 * d] = Dl), (BBUF[2 * d + 1] = Dh);\n}\nclass BLAKE2b extends _blake_js__WEBPACK_IMPORTED_MODULE_1__.BLAKE {\n    constructor(opts = {}) {\n        super(128, opts.dkLen === undefined ? 64 : opts.dkLen, opts, 64, 16, 16);\n        // Same as SHA-512, but LE\n        this.v0l = B2B_IV[0] | 0;\n        this.v0h = B2B_IV[1] | 0;\n        this.v1l = B2B_IV[2] | 0;\n        this.v1h = B2B_IV[3] | 0;\n        this.v2l = B2B_IV[4] | 0;\n        this.v2h = B2B_IV[5] | 0;\n        this.v3l = B2B_IV[6] | 0;\n        this.v3h = B2B_IV[7] | 0;\n        this.v4l = B2B_IV[8] | 0;\n        this.v4h = B2B_IV[9] | 0;\n        this.v5l = B2B_IV[10] | 0;\n        this.v5h = B2B_IV[11] | 0;\n        this.v6l = B2B_IV[12] | 0;\n        this.v6h = B2B_IV[13] | 0;\n        this.v7l = B2B_IV[14] | 0;\n        this.v7h = B2B_IV[15] | 0;\n        const keyLength = opts.key ? opts.key.length : 0;\n        this.v0l ^= this.outputLen | (keyLength << 8) | (0x01 << 16) | (0x01 << 24);\n        if (opts.salt) {\n            const salt = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.u32)((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.toBytes)(opts.salt));\n            this.v4l ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.byteSwapIfBE)(salt[0]);\n            this.v4h ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.byteSwapIfBE)(salt[1]);\n            this.v5l ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.byteSwapIfBE)(salt[2]);\n            this.v5h ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.byteSwapIfBE)(salt[3]);\n        }\n        if (opts.personalization) {\n            const pers = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.u32)((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.toBytes)(opts.personalization));\n            this.v6l ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.byteSwapIfBE)(pers[0]);\n            this.v6h ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.byteSwapIfBE)(pers[1]);\n            this.v7l ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.byteSwapIfBE)(pers[2]);\n            this.v7h ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.byteSwapIfBE)(pers[3]);\n        }\n        if (opts.key) {\n            // Pad to blockLen and update\n            const tmp = new Uint8Array(this.blockLen);\n            tmp.set((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.toBytes)(opts.key));\n            this.update(tmp);\n        }\n    }\n    // prettier-ignore\n    get() {\n        let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;\n        return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];\n    }\n    // prettier-ignore\n    set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {\n        this.v0l = v0l | 0;\n        this.v0h = v0h | 0;\n        this.v1l = v1l | 0;\n        this.v1h = v1h | 0;\n        this.v2l = v2l | 0;\n        this.v2h = v2h | 0;\n        this.v3l = v3l | 0;\n        this.v3h = v3h | 0;\n        this.v4l = v4l | 0;\n        this.v4h = v4h | 0;\n        this.v5l = v5l | 0;\n        this.v5h = v5h | 0;\n        this.v6l = v6l | 0;\n        this.v6h = v6h | 0;\n        this.v7l = v7l | 0;\n        this.v7h = v7h | 0;\n    }\n    compress(msg, offset, isLast) {\n        this.get().forEach((v, i) => (BBUF[i] = v)); // First half from state.\n        BBUF.set(B2B_IV, 16); // Second half from IV.\n        let { h, l } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromBig(BigInt(this.length));\n        BBUF[24] = B2B_IV[8] ^ l; // Low word of the offset.\n        BBUF[25] = B2B_IV[9] ^ h; // High word.\n        // Invert all bits for last block\n        if (isLast) {\n            BBUF[28] = ~BBUF[28];\n            BBUF[29] = ~BBUF[29];\n        }\n        let j = 0;\n        const s = _blake_js__WEBPACK_IMPORTED_MODULE_1__.SIGMA;\n        for (let i = 0; i < 12; i++) {\n            G1b(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n            G2b(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n            G1b(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n            G2b(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n            G1b(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n            G2b(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n            G1b(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n            G2b(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n            G1b(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n            G2b(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n            G1b(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n            G2b(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n            G1b(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n            G2b(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n            G1b(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n            G2b(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n        }\n        this.v0l ^= BBUF[0] ^ BBUF[16];\n        this.v0h ^= BBUF[1] ^ BBUF[17];\n        this.v1l ^= BBUF[2] ^ BBUF[18];\n        this.v1h ^= BBUF[3] ^ BBUF[19];\n        this.v2l ^= BBUF[4] ^ BBUF[20];\n        this.v2h ^= BBUF[5] ^ BBUF[21];\n        this.v3l ^= BBUF[6] ^ BBUF[22];\n        this.v3h ^= BBUF[7] ^ BBUF[23];\n        this.v4l ^= BBUF[8] ^ BBUF[24];\n        this.v4h ^= BBUF[9] ^ BBUF[25];\n        this.v5l ^= BBUF[10] ^ BBUF[26];\n        this.v5h ^= BBUF[11] ^ BBUF[27];\n        this.v6l ^= BBUF[12] ^ BBUF[28];\n        this.v6h ^= BBUF[13] ^ BBUF[29];\n        this.v7l ^= BBUF[14] ^ BBUF[30];\n        this.v7h ^= BBUF[15] ^ BBUF[31];\n        BBUF.fill(0);\n    }\n    destroy() {\n        this.destroyed = true;\n        this.buffer32.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\n/**\n * BLAKE2b - optimized for 64-bit platforms. JS doesn't have uint64, so it's slower than BLAKE2s.\n * @param msg - message that would be hashed\n * @param opts - dkLen, key, salt, personalization\n */\nconst blake2b = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructorWithOpts)((opts) => new BLAKE2b(opts));\n//# sourceMappingURL=blake2b.js.map\n\n//# sourceURL=webpack://my-project/./node_modules/@noble/hashes/esm/blake2b.js?");

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/crypto.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/crypto.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\nconst crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map\n\n//# sourceURL=webpack://my-project/./node_modules/@noble/hashes/esm/crypto.js?");

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/sha256.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/sha256.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_md.js */ \"./node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Maj)(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map\n\n//# sourceURL=webpack://my-project/./node_modules/@noble/hashes/esm/sha256.js?");

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   byteSwap: () => (/* binding */ byteSwap),\n/* harmony export */   byteSwap32: () => (/* binding */ byteSwap32),\n/* harmony export */   byteSwapIfBE: () => (/* binding */ byteSwapIfBE),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotl: () => (/* binding */ rotl),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/crypto */ \"./node_modules/@noble/hashes/esm/crypto.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"./node_modules/@noble/hashes/esm/_assert.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nconst byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nconst byteSwapIfBE = isLE ? (n) => n : (n) => byteSwap(n);\n// In place byte swap for Uint32Array\nfunction byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map\n\n//# sourceURL=webpack://my-project/./node_modules/@noble/hashes/esm/utils.js?");

/***/ }),

/***/ "./node_modules/@scure/base/lib/esm/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@scure/base/lib/esm/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertNumber: () => (/* binding */ assertNumber),\n/* harmony export */   base16: () => (/* binding */ base16),\n/* harmony export */   base32: () => (/* binding */ base32),\n/* harmony export */   base32crockford: () => (/* binding */ base32crockford),\n/* harmony export */   base32hex: () => (/* binding */ base32hex),\n/* harmony export */   base32hexnopad: () => (/* binding */ base32hexnopad),\n/* harmony export */   base32nopad: () => (/* binding */ base32nopad),\n/* harmony export */   base58: () => (/* binding */ base58),\n/* harmony export */   base58check: () => (/* binding */ base58check),\n/* harmony export */   base58flickr: () => (/* binding */ base58flickr),\n/* harmony export */   base58xmr: () => (/* binding */ base58xmr),\n/* harmony export */   base58xrp: () => (/* binding */ base58xrp),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64nopad: () => (/* binding */ base64nopad),\n/* harmony export */   base64url: () => (/* binding */ base64url),\n/* harmony export */   base64urlnopad: () => (/* binding */ base64urlnopad),\n/* harmony export */   bech32: () => (/* binding */ bech32),\n/* harmony export */   bech32m: () => (/* binding */ bech32m),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   bytesToString: () => (/* binding */ bytesToString),\n/* harmony export */   createBase58check: () => (/* binding */ createBase58check),\n/* harmony export */   hex: () => (/* binding */ hex),\n/* harmony export */   str: () => (/* binding */ str),\n/* harmony export */   stringToBytes: () => (/* binding */ stringToBytes),\n/* harmony export */   utf8: () => (/* binding */ utf8),\n/* harmony export */   utils: () => (/* binding */ utils)\n/* harmony export */ });\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain(...args) {\n    const id = (a) => a;\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b) => (c) => a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.map((x) => x.decode).reduce(wrap, id);\n    return { encode, decode };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(alphabet) {\n    return {\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = '') {\n    if (typeof separator !== 'string')\n        throw new Error('join separator should be string');\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n                throw new Error('join.encode input should be array of strings');\n            for (let i of from)\n                if (typeof i !== 'string')\n                    throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error('join.decode input should be string');\n            return to.split(separator);\n        },\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits, chr = '=') {\n    assertNumber(bits);\n    if (typeof chr !== 'string')\n        throw new Error('padding chr should be string');\n    return {\n        encode(data) {\n            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of data)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.encode: non-string input=${i}`);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of input)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('Invalid padding: string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                if (!(((end - 1) * bits) % 8))\n                    throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('normalize fn should be function');\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2)\n        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data))\n        throw new Error('convertRadix: data should be array');\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d) => {\n        assertNumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`Wrong integer: ${d}`);\n    });\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < digits.length; i++) {\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                (from * carry) / from !== carry ||\n                digitBase - digit !== from * carry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            carry = digitBase % to;\n            const rounded = Math.floor(digitBase / to);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!rounded)\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = /* @__NO_SIDE_EFFECTS__ */ (a, b) => (!b ? a : gcd(b, a % b));\nconst radix2carry = /*@__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data))\n        throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data) {\n        assertNumber(n);\n        if (n >= 2 ** from)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix.decode input should be array of numbers');\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        },\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix2.decode input should be array of numbers');\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction unsafeWrapper(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('unsafeWrapper fn should be function');\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== 'function')\n        throw new Error('checksum fn should be function');\n    return {\n        encode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\n// prettier-ignore\nconst utils = {\n    alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\nconst base16 = /* @__PURE__ */ chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nconst base32 = /* @__PURE__ */ chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nconst base32nopad = /* @__PURE__ */ chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), join(''));\nconst base32hex = /* @__PURE__ */ chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nconst base32hexnopad = /* @__PURE__ */ chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), join(''));\nconst base32crockford = /* @__PURE__ */ chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nconst base64 = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nconst base64nopad = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), join(''));\nconst base64url = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nconst base64urlnopad = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));\n// base58 code\n// -----------\nconst genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));\nconst base58 = /* @__PURE__ */ genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nconst base58flickr = /* @__PURE__ */ genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nconst base58xrp = /* @__PURE__ */ genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\n// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n// Block encoding significantly reduces quadratic complexity of base58.\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nconst base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nconst createBase58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), base58);\n// legacy export, bad name\nconst base58check = createBase58check;\nconst BECH_ALPHABET = /* @__PURE__ */ chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string')\n            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        if (prefix.length === 0)\n            throw new TypeError(`Invalid prefix length ${prefix.length}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string')\n            throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || (limit !== false && str.length > limit))\n            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        const sepIndex = lowered.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = lowered.slice(0, sepIndex);\n        const data = lowered.slice(sepIndex + 1);\n        if (data.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(data).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!data.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };\n}\nconst bech32 = /* @__PURE__ */ genBech32('bech32');\nconst bech32m = /* @__PURE__ */ genBech32('bech32m');\nconst utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\nconst hex = /* @__PURE__ */ chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n    utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\nconst coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\nconst bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!isBytes(bytes))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nconst str = bytesToString; // as in python, but for bytes only\nconst stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nconst bytes = stringToBytes;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://my-project/./node_modules/@scure/base/lib/esm/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./main.js");
/******/ 	
/******/ })()
;